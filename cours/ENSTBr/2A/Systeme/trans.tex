\iffalse
Passer dessin RAID en maths normales

 SAN, NAS

matrix

Saman Amarasinghe. The Looming Software Crisis due to the Multicore Menace. Presented at the CISE Distinguished Lecture, National Science Foundation, Washington D. C., February, 2007. (Talk: PDF, PPT; BibTeX)
http://cag.lcs.mit.edu/commit/papers/06/MulticoreMenace.pdf
          The \og Software Crisis\fg
 To put it quite bluntly: as long as there were no
machines, programming was no problem at all;
when we had a few weak computers,
programming became a mild problem, and now
we have gigantic computers, programming has
become an equally gigantic problem."
               -- E. Dijkstra, 1972 Turing Award Lecture



http://opensolaris.org/os/community/zfs/docs/


reclasser les transparents, c'est le gros bazar :-(

Rajouter ordonnancement de biblio de Jérôme Gallard.

Rajouter des choses sur les modèles d'exécutions, avec pile, contexte
d'exécution... Style partir de biblio de Damien Picard sur Smalltalk

sexe octets
http://www.pps.jussieu.fr/~armand/M2_SEM/Biblio/holy-war-plea-4-peace.html


http://www.pps.jussieu.fr/~armand/M2_SEM/index.html

http://www.pps.jussieu.fr/~armand


http://handlers.sans.org/tliston/ThwartingVMDetection_Liston_Skoudis.pdf
http://searchsecurity.techtarget.com/columnItem/0,294698,sid14_gci1197021,00.html

Low level benchmarking on Mac OS X and Linux
Lmbench 3.0 provides a suite of micro-benchmarks that measure the
bottlenecks at the Unix operating system and CPU level. We were not able
to install Yellow Dog Linux on the 2.7 GHz Apple machine, although the
paper specs (excluding the CPU) were exactly the same as our 2.5 GHz
PowerMac. Some small chipset tweak or firmware change is probably the
cause of our YDL installation failure on the newest and latest Apple
PowerMac
http://www.anandtech.com/mac/showdoc.aspx?i=2520&p=7


http://www.trnmag.com/Stories/2005/072705/Fingernails_store_data_072705.html
idées d'examen

Comparaison IDE-SCSI

Revoir la partie introductive processus lourds/légers 


http://french.joelonsoftware.com/Articles/LeakyAbstractions.html


Rajouter des transparents d'une autre couleur pour le niveau avancé ?

Co-routines

http://www.brouhaha.com/~eric/retrocomputing/intel/iapx432/

http://www.neebu.net/~khuon/humour/images/1969_2-node_map.gif
http://www.lk.cs.ucla.edu/LK/Inet/birth.html

http://www.scs.cs.nyu.edu/~dm/home/classes.html

http://www.x.org/X11_protocol.html

http://opengfs.sourceforge.net/showdoc.php?docpath=cvsmirror/opengfs/docs/ogfs-ondisk-layout&doctitle=Filesystem_On-Disk_Layout&docauthor=dominik.vogt(at)gmx.de

http://www.dragonflybsd.org

À commander à la bibliothèque

Book: The Design and Implementation of the FreeBSD Operating System

   URL: http://www.mckusick.com/FreeBSDbook.html

   Contact: Kirk McKusick <mckusick@freebsd.org>
   Contact: George Neville-Neil <gnn@neville-neil.com>

   The new Book "The Design and Implementation of the FreeBSD Operating
   System" is the successor of the legendary "The Design and
   Implementation of 4.4BSD" book which has become the de-facto standard
   for teaching of Operating System internals in universities world-wide.

   This new and completely reworked edition is based on FreeBSD 5.2 and
   the upcoming FreeBSD 5.3 releases and contains in-details looks into
   all areas (from virtual memory management to interprocess
   communication and network stack) of the operating system on 700 pages.

   It is now in final production by Addison-Wesley and will be available
   in early August 2004. The ISBN is 0-201-70245-2.


Vérifier le plan

tune2fs -l /dev/hda2

Introduire Posix par rapport à Unix et WNT

http://www.forchheimer.se/bfm/

listpunch.c et protocole cartes perforées dans Bitnet

Détailler un int 80h Linux

void point(int x,int y)
{
  _CX = x ;
  _DX = y ;
  _AL = couleur ;
  _AH = 0x0C ;
  geninterrupt(0x10) ;          /* Fonction 0Ch de l'int. 10h */
}

Sous IBM la notion de login Ã©tait liÃ©e Ã  la notion de boot de machine virtuelle OS360 et du coup reset -> login...

http://sam.zoy.org/lectures/20020424-debian/

http://www.over-yonder.net/~fullermd/rants/bsd4linux

http://www.openafs.org
http://www.coda.cs.cmu.edu

http://cs.gmu.edu/~menasce/osbook/
Plan9

Un exemple de top/ps

Contrôles de processus

http://lufs.sourceforge.net/lufs/intro.html

[2. application/pdf; BrevetSouris.PDF]

Présentation de purify et autres

Rajouter une partie sur la séparation langage (C)/Bibliothèque (scanf,
strdup)/fonctions système/interruptions/noyaux.


Rajouter de la programmation système.


From: Claude Kaiser <kaiser@cnam.fr>
Subject: Diffusion de cours systemes
To: arp@cines.fr, membres-ASF@essi.fr, strqds@laas.fr
Cc: kaiser@cnam.fr
Date: Thu, 4 Jul 2002 19:23:13 +0200

Merci aux administrateurs des listes de diffusion de bien vouloir diffuser
cette information qui pourrait être utile a certains


************************************
POUR DIFFUSION
Bonjour
Chers collegues
Vous cherchez un cours systeme tout fait, avec des documents (textes,
photocopies de transparents, exercices, sujets d'examens), le tout
disponible pour la rentree, gratuit (style logiciel libre), telechargeable.
Voici quelques indications utiles

1) le livre CROCUS systemes d'exploitation des ordinateurs, Dunod 1975,
livre "historique", est digitalisé dans la bibliotheque numerique du CNAM
et son acces et son utilisation sont gratuits. Allez voir a
http://cnum.cnam.fr

2) je viens de remettre a jour un cours systemes de deuxieme cycle CNAM
avec texte, illustrations, exercices, sujets et corrigés d'examen. C'est
gratuit et telechargeable. Utilisable selon les habitudes des logiciels
libres (voir indications de copyright dans les fichiers pdf en
ligne). Plus vous le copierez, plus vous l'utiliserez (en me tenant au
courant, en m'envoyant vos remarques, plus je serai content); Allez voir a
http://deptinfo.cnam.fr/Enseignement/CycleProbatoire/SRI/Systemes

3) autres cours CNAM sur les systemes, qui sont gratuits et en ligne
cours de premier cycle
http://deptinfo.cnam.fr/Enseignement/CycleA/AMSI/
cours de second cycle voir
cours sur la programmation concurrente et sa validation
http://deptinfo.cnam.fr/Enseignement/CycleSpecialisation/ACCOV/
cours sur les systemes repartis
http://deptinfo.cnam.fr/Enseignement/CycleSpecialisation/SAR/

Bien cordialement
Merci de diffuser abondamment cette information
Claude KAISER
Professeur
Titulaire de la chaire D'Informatique Programmation
Conservatoire National des Arts et Métiers
292, rue Saint-Martin,75141 Paris Cedex 03, France
tél: +33 (1) 40 27 22 77  fax: +33 (1) 40 27 27 09
courriel : kaiser@cnam.fr
Laboratoire de recherche CEDRIC http://cedric.cnam.fr
Equipe : objets temps et ordres dans les systemes repartis
cours du Département d'informatique http://www.cnam.fr/Enseignement/
manuel et transparents du cours systemes B
http://deptinfo.cnam.fr/Enseignement/CycleProbatoire/SRI/Systemes
          Devise du CNAM : "Docet omnes ubique".





http://computer.org/education/cc2001/final/chapter05.htm

expliquer le zen : Le moins de matériel possible
mode superviseur
MMU
interruption

exemple : simuler un framebuffer en périphérique xy ou l'inverse.

compression de la mémoire
cache

expliquer les appels de fonction, variables automatiques, piles.

Comparer à l'appel système

Pourquoi pas toujours d'OS ? Le prix...

Faire plus un cours pour les non informaticiens

Mettre des dessins et des exemples concrets (style mon CC 2002)

Pas plus de 2 tr/page distribué aux élèves

Faire plus de TPs

Faire un poly pour les gens n;aynt pas fait d'oinfo,



Rajouter des systèmes de nommage distribués : NIS, DNS,...

Rajouter un exemple de debug avec le support de l'OS.

Parler de l'entrelacement des secteurs, des algos de déplacement de tête.

Parler des implications des OS sur la performance.

\begin{trans}{Code translatable} Vraiment pas clair

Rajouter fichiers textes et binaires.

Mettre un exemple de vraie machine multipro (et monopro ?)

Regarder fiches d'évaluation au moins pour les intitulés !
\fi


%\documentclass[compress,10pt,handout]{beamer}
\documentclass[compress,10pt]{beamer}
%\documentclass{article}
%\usepackage{beamerarticle}
\usepackage{pgfpages}
%\pgfpagesuselayout{4 on 1}[a4paper,landscape,border shrink=5mm]
%\pgfpagesuselayout{4 on 1}[a4paper,landscape]

\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{array}
\usepackage{amsmath,wasysym,marvosym}
\usepackage{alltt,exemple}
\usepackage[francais]{babel}

%% Mes choses bien à moi :
\usepackage{beamer_rk,perso2e,abbrev_reactive,getVersion,exemple}
\usepackage{listings}
%\usepackage{pgfpages}
%\pgfpagesuselayout{4 on 1}[a4paper,landscape,border shrink=5mm]

%% bbold2e doit apparaître après trans2e_rk :
\usepackage{bbold2e}
%\input{abbrev_pomp}

%\usepackage[backref,dvips,pdfauthor=Ronan.Keryell@enst-bretagne.fr]{hyperref}

%\usepackage{trans2e_rk,LienPDF}
\usepackage{LienPDF}

\lstset{extendedchars=true, language=C, basicstyle=\footnotesize\ttfamily, numbers=left,
  numberstyle=\tiny, stepnumber=2, numberfirstline=true, showspaces=true,
  showstringspaces=false, showtabs=true,
  tabsize=8, tab=\rightarrowfill, keywordstyle=\orange\bf,
  stringstyle=\rmfamily, commentstyle=\rmfamily\itshape}

\usepackage[dvips]{preview}
\PreviewEnvironment{trans}
\PreviewEnvironment{frame}


\def\LinuxLXR{http://lxr.linux.no/}
%\def\LinuxDecl{\catcode`_=12\@LinuxDecl}
\def\LinuxDecl{\@LinuxDecl}
\def\@LinuxDecl#1#2{\href{\LinuxLXR ident?i=#1}{#1} [{\red\href{\LinuxLXR source/#2}{#2}}]}
\def\LinuxFuncDecl#1#2{\href{\LinuxLXR ident?i=#1}{#1}() [{\red\href{\LinuxLXR source/#2}{#2}}]}
%{sys_clone}{arch/i386/kernel/process.c}
%http://kernel.enstb.org/lxr/http/ident?i=sys_clone
\def\LinuxFile#1{\href{\LinuxLXR source/#1}{[{\red #1}]}}

\getRCSDollarsVersion$Revision: 1.18 $



\newcommand{\NAMED}{NAMED}

\newcommand{\RFC}[1]{\href{http://www.pasteur.fr/cgi-bin/aglimpse/01?query=RFC+#1}{RFC~#1}}


\input{titre}





\begin{document}

%\sloppy


%\DealWithColors


%\TRANSTITLESIZE
%\slideframe{none}
\begin{frame}[plain]
  %\couleurtexte
  \maketitle
  %\addtocounter{slide}{-1}
  %\slidepagestyle{empty}
\end{frame}
%\TRANSNORMALSIZE

%% Maison :
%\def\vavers{}
%\def\LeLogoEnBasADroite{}
%\def\LeLogoEnBasAGauche{}

%\slidepagestyle{CRI}


\begin{frame}{Copyright (c)}
  \begin{itemizer}
  \item Copyright (c) 1986--2037 by \texttt{Ronan.Keryell@enst-bretagne.fr}.
    
    This material may be distributed only subject to the terms and
    conditions set forth in the Open Publication License, v1.0 or later
    (the latest version is presently available at
    \LienPDF{http://www.opencontent.org/openpub/}).
    
  \item Si vous améliorez ces cours, merci de m'envoyer vos modifications
    ! \smiley
    
  \item Transparents 100\,\% à base de logiciels libres (\LaTeX,...)
  \end{itemizer}
\end{frame}


\section*{Introduction}


\begin{trans}{Le cours}
  \begin{itemizer}
  \item « Je suis contre les polys » (cf CdV) mais :
    \begin{itemizet}
    \item Cours « cliquable »
    \item Dense \smiley
    \item Table des matières
    \end{itemizet}
  \item Pas de petites classes sur cette partie \vavers posez des
    questions !!! \smiley
  \item Beaucoup d'exemples basés sur Unix (accès aux sources) mais...
  \item Retenir idées et concepts plutôt que les exemples précis
  \item Partie programmation faite par Alain \textsc{Leroy} \& Christophe
    \textsc{Lohr}
  \item Partie sur Windows faite par Daniel \textsc{Bourget}
  \item Difficulté : comment contenter les candides et les cyborgs
    \textsc{RésÉl}iens ? \frownie \vavers Challenge ! \smiley
  \end{itemizer}
\end{trans}


\begin{trans}{Problématique}
  \begin{itemizer}
  \item Ubiquité de l'informatique
  \item Beaucoup d'applications
  \item Reposent sur des fonctionalités basiques communes
    \begin{itemizet}
    \item Interagir avec l'extérieur
    \item Assurer démarrage, vie et mort des programmes
    \item Confort d'utilisation mais aussi de développement
    \item Besoin de sécurité d'exécution
    \end{itemizet}
  \item De nombreux types d'ordinateurs existent
    \begin{itemizet}
    \item Assurer portabilité
    \item Assurer pérénité des développements
    \end{itemizet}
  \end{itemizer}
  \belleboite{Capitaliser l'expérience}
\end{trans}


\begin{frame}[allowframebreaks]{Le plan}
  \begin{multicols}{2}
    \tableofcontents
  \end{multicols}
\end{trans}


\section*{Fonctions d'un système d'exploitation}


\begin{trans}{Introduction}
  Fournit 2 types de services
  \begin{itemizer}
  \item Machine virtuelle étendue plus agréable que la vraie machine brute
    \begin{itemizet}
    \item Plusieurs programmes fonctionnent en même temps
    \item Plusieurs utilisateurs
    \item Mémoire arbitrairement grande
    \item Fichiers
    \item Interfaces (graphiques) sympathiques
    \item ...
    \end{itemizet}
    Détails cachés de manière \emph{transparente}
  \item Gestion optimale des ressources
    \begin{itemizet}
    \item Processeurs
    \item Mémoire
    \item Périphériques d'entrée-sortie
    \item Gestion de la qualité de service (surtout en mode
      multi-utilisateur...)
      \begin{itemizec}
      \item Latence, temps de réponse : mode intéractif
      \item Débit : centre de calcul
      \item Contraintes temps réel : gestion d'un processus industriel
      \item Tolérance aux pannes : centrales nucléaires, avions
      \item ...
      \end{itemizec}
    \end{itemizet}
  \end{itemizer}
\end{trans}


\begin{trans}{Machine Virtuelle Étendue}
  \begin{itemizer}
  \item Processus : abstraction de processeur virtuel
    \begin{itemizet}
    \item Programme s'exécutant sur un processeur
    \item Contexte d'exécution
    \item Protection
    \end{itemizet}
  \item Atomicité : qui \emph{paraît} insécable
    \begin{itemizet}
    \item Lecture, écriture
    \item Transactions : début, fin, abandon possible sans casse
    \end{itemizet}
  \item Fichier abstrait
    \begin{itemizet}
    \item Conteneur de données, de programmes, répertoires
    \item Périphérique (disquette)
    \item Contrôle de n'importe quoidans Unix...
    \end{itemizet}
  \end{itemizer}
\end{trans}


\begin{trans}{Abstraction de fichier}
  Dans un système imaginaire...
  \psfiglarge{systemes_exploitation/fichiers.idraw}
\end{trans}


\begin{trans}{Exemples de fichiers et fichiers spéciaux}
  \begin{itemizer}
  \item Contrôler des « périphériques » (\texttt{/dev} sous Unix)
    \begin{itemizet}
    \item Périphérique de stockage : \texttt{/dev/fd0} (disquette),...
    \item Terminal \texttt{/dev/tty} (clavier, écran, souris
      \texttt{/dev/mouse}, \texttt{/dev/mouse1})
    \item Lien de communication \texttt{/dev/eth0}, socket
    \item \verb|cp truc /dev/lp| ou \verb|copy truc prn:| imprime le
      contenu de \texttt{truc}
    \item \verb'cat /dev/zero > /dev/null' met des 0 à la poubelle
    \item \verb'cat /dev/random > a' crée un fichier de caractères
      aléatoires
    \item Mémoire (principale ou secondaire) : \texttt{/dev/mem} (fichier
      contenant une copie de la mémoire de l'ordinateur)
    \item Informations sur des périphériques (\texttt{/dev/sndstat})
      (mélange des genres historique...)
    \end{itemizet}
  \item Sockets : tuyaux
    \begin{itemizet}
    \item Entre machine (\verb|PF_INET|,...)
    \item \verb'xwd -root -display pigeon:0 | xwud' : entre processus
    \item Pipes nommés
    \end{itemizet}
  \item Processus dans \texttt{/proc}
    \begin{itemizet}
    \item Fichier mémoire processus
    \item Fichiers utilisés par processus
    \end{itemizet}
  \item Contrôle et information système \texttt{/sys}
  \end{itemizer}
\end{trans}


\begin{trans}{Transparence et opacité}
  \belleboite{« C'est transparent à l'utilisateur » $\equiv$ Il ne voit
    rien \vavers{} ¡ c'est opaque ! \smiley}
  \begin{itemizer}
  \item Hétérogénéité
    \begin{itemizet}
    \item Modèles et marques d'ordinateur
    \item Taille des mots et rangement des octets dans les mots
    \item Systèmes d'exploitation différents
    \item Périphériques différents
    \end{itemizet}
  \item Localisation
    \begin{itemizet}
    \item Fichier local ou non
    \item Ordinateur distant ou pas
    \end{itemizet}
  \item Migration \& mobilité
    \begin{itemizet}
    \item Serveurs qui se déplacent
    \item Objets migrateurs
    \item Ressources distribuées
    \end{itemizet}
  \item Réplication (tolérance aux pannes et performances)
    \begin{itemizet}
    \item Multiplication des serveurs
    \item Mécanisme de caches
    \end{itemizet}
  \item Concurrence et parallélisme
    \begin{itemizet}
    \item Sérialisabilité
    \end{itemizet}
  \end{itemizer}
  \vavers{} Définition de l'interface de programmation du système
  \begin{itemizer}
  \item Objets définis dans l'interface
  \item Relations inter-objets ?
  \item Comment communiquer ?
  \end{itemizer}

  \newslide
  
  Exemple de concept : partage de données dans une variable globale
  (locale ou distante)\\
  Le système va masquer la réalité :
  \begin{itemizer}
  \item Réseau haut-débit
  \item Mémoire globale
  \item Mécanismes de cache à cohérence forte (atomique)
  \end{itemizer}
\end{trans}



\begin{trans}{Nirvana des systèmes}
  \begin{itemizer}
  \item Vrai système distribué
  \item Pas un système réseau
  \item Vision monosite
  \item Espace de nommage unique (infini...)
  \item \Attention{} ¿ Comment concilier transparence et performance ?
  \end{itemizer}
  \belleboite{\vavers Compromis cacher $\neq$ gérer...}
  
  \Attention{} Bien comprendre comment cela marche si on ne veut pas
  tomber dans des pièges cachés... \vavers{} Ce cours !
\end{trans}


\begin{trans}{Un ordinateur dans une perspective logicielle}
  \psfiglarge{systemes_exploitation/ordinateur_et_systeme.idraw}
  
  \Attention{} Le grand public ne voit que le haut et le fenêtrage...
\end{trans}


\begin{trans}{DCE --- \protect\emph{Distributed Computing Environment}}
  \psfiglarge{systemes_exploitation/modele_DCE.idraw}
\end{trans}


\begin{trans}{Évolution logicielle}
  \centerline{\psframebox[fillstyle=solid,fillcolor=cornsilk,%
    linestyle=none]{%
      \includegraphics[width=0.9\hsize]{systemes_exploitation/LIsaac.eps}}}

  {\scriptsize Extrait de « Le projet Isaac: une alternative objet de haut
    niveau pour la programmation système », Benoit Sonntag,
    \textsc{cfse}2005}
\end{trans}


\begin{trans}{Pourquoi ce cours en 1A/2A... puis en 3A ?}
  \begin{itemizer}
  \item ¡\,Parce que !
  \item Informatique et donc systèmes d'exploitation partout
  \item Vernis aux futurs {\red ingénieurs} dans la salle
  \item Comprendre la problématique
  \item \Attention{} Sirènes graphiques : une interface graphique ne fait
    que cacher la complexité qui réapparaît en cas de problème...
  \item Nécessité de comprendre comment cela fonctionne !
  \item Plein d'astuces réutilisables dans la vie de tout les jours
    \begin{itemizet}
    \item Programmation
    \item Optimisation
    \item Gestion de production
    \item Gestion de son potager
    \item Gestion de son agenda
    \item Gestion de son carnet de bal
    \item ...
    \end{itemizet}
  \end{itemizer}
\end{trans}


\begin{trans}{Bibliographie}
  \begin{itemizer}
  \item « \emph{Systèmes d'exploitation} », Andrew \textsc{Tanenbaum},
    2\up{ème} édition, Pearson Education, 2003
  \item « \emph{Virtual Machines} --- \emph{Versatile Platforms for
      Systems and Processes} », James E. \textsc{Smith} \& Ravi
    \textsc{Nair}. Morgan Kaufmann/Elsevier, 2005 (contient aussi un cours
    d'architecture à la fin)
  \item Les bases (un peu d'histoire) : « \emph{Systèmes d'exploitation
      des ordinateurs : principes de conception/CROCUS} », Paris : Dué,
    J. Briat, B.  Canet, E. Cleemann, J.C.  Derniame, J. Ferrié,
    C. Kaiser, S.  Krakowiak, J. Mossière, J.-P.  Verjus, 1978
    \LienPDF{http://cnum.cnam.fr/fSYN/8CA2680.html}
  \item Cours du CNAM
    \begin{itemizet}
    \item
      \LienPDF{http://deptinfo.cnam.fr/Enseignement/CycleProbatoire/SRI/Systemes}
    \item \LienPDF{http://deptinfo.cnam.fr/Enseignement/CycleA/AMSI}
    \item
      \LienPDF{http://deptinfo.cnam.fr/Enseignement/CycleSpecialisation/ACCOV}
    \item \LienPDF{http://deptinfo.cnam.fr/Enseignement/CycleSpecialisation/SAR}
    \end{itemizet}
  \item \LienPDF{http://cui.unige.ch/~billard/systemeII/} cours en
    français de David Billard
  \item « UNIX Internals: The New Frontiers », Uresh Vahalia, October,
    1995, Prentice Hall Engineering/Science/Mathematics
    \LienPDF{http://www.phptr.com/ptrbooks/esm_0131019082.html}
  \item « Operating systems : a modern perspective », Gary J. Nutt,
    Addison Wesley, 1997
  \item « The Magic garden explained : the internals of UNIX System V
    release 4 : an open systems design », B.  Goodheart ; J. Cox,
    Prentice-Hall, 1994
\end{itemizer}
\end{trans}


\begin{trans}{Bibliographie Linux}
  \begin{itemizer}
  \item Que les sources soient avec vous ! \smiley
    \begin{itemizet}
    \item Récupérer le noyau Linux \LienPDF{http://kernel.org}
    \item Le code hypertextuel \LienPDF{http://lxr.linux.no} (et plus
      proche de nous \LienPDF{http://kernel.enstb.org})
    \item Penser à utiliser les \emph{tags} dans son éditeur favori
      \begin{itemizec}
      \item \texttt{make TAGS} crée un fichier \texttt{TAGS} pour les
        \texttt{Emacs}
      \item \texttt{make tags} crée un fichier \texttt{tags} pour les
        \texttt{vi}
      \end{itemizec}
    \end{itemizet}
  \item Livres
    \begin{itemizet}
    \item « \emph{Linux Kernel Development} » Robert \textsc{Love}. Novell
      Press, 2$^{\text{ème}}$ édition, 12 janvier 2005
    \item « \emph{Linux Device Drivers} », Jonathan \textsc{Corbet},
      Alessandro \textsc{Rubini} et Greg \textsc{Kroah-Hartman}. O'Reilly,
      3$^{\text{ème}}$ édition, février 2005.
      \LienPDF{http://lwn.net/Kernel/LDD3}
    \end{itemizet}
  \item Gazette de discussion sur Linux
    \LienPDF{http://www.kernel-traffic.org}
  \item \LienPDF{http://lwn.net/Kernel} Linux kernel development
  \item The linux-kernel mailing list FAQ
    \LienPDF{http://www.tux.org/lkml} (un peu vieux)
  \item Index of Documentation for People Interested in Writing and/or
    Understanding the Linux Kernel
    \LienPDF{http://jungla.dit.upm.es/~jmseyas/linux/kernel/hackers-docs.html}
  \item \LienPDF{http://lwn.net/Articles/2.6-kernel-api} \emph{2.6 API
      changes.  A regularly-updated summary of changes to the internal
      kernel API}
  \item \LienPDF{http://lwn.net/Articles/driver-porting} The Porting
    drivers to 2.6 series: over 30 articles describing, in detail, how the
    internal kernel API has changed in the 2.6 release
  \item « Linux Internals », Moshe Bar, 2000, The McGraw-Hill Companies,
    Inc.
  \item « Linux Kernel 2.4 Internals », Tigran Aivazian,
    \LienPDF{http://www.moses.uklinux.net/patches/lki.html}
  \item « The Linux Kernel 2.0.33 », David A Rusling,
    \LienPDF{http://www.linuxhq.com/guides/TLK/tlk.html}
  \end{itemizer}
\end{trans}


\section{Historique}



\begin{trans}{Historique}
  %% Voir mes autres cours
  \LienPDF{http://www.computerhistory.org}\\
  \LienPDF{http://histoire.info.online.fr}
  \begin{itemizer}
  \item 1945--1955
    \begin{itemizet}
    \item Pas de système d'exploitation
    \item Tout faire à la main
    \end{itemizet}
  \item 1955--1965
    \begin{itemizet}
    \item Langages de plus haut niveau
    \item Générations de machines
    \end{itemizet}
  \item 1965--1985
    \begin{itemizet}
    \item Multiprogrammation
    \item Temps partagé
    \item Gros systèmes
    \end{itemizet}
  \item 1985--$\cdots$
    \begin{itemizet}
    \item Ordinateurs personnels
    \item Stations de travail
    \item Réseaux (Internet)
    \item Systèmes distribués
    \end{itemizet}
  \end{itemizer}
  \LienPDF{http://www.computer.org/50/history}
\end{trans}


\begin{trans}{1945--1955 : ordinateur séquentiel}
  %% Voir mon cous de La Villette
  Principes de \textsc{Eckert}, \textsc{Mauchly} et \textsc{von}
  \textsc{Neumann}, années 1940 : une mémoire contient des données
  \emph{ET} un programme
  
  \psfiglarge{architecture/von_Neumann_couleur.idraw}
  
  + Entrées-sorties sur un des chemins de données
  
  \vavers concept d'ordinateur universel en 1946 : ENIAC. 18000 tubes à
  vide, 30 tonnes, 174 kW, 5000~$+/$s, 333~$×/$s à 10 chiffres,
  modifié plus tard avec programme en mémoire

  \psfigtaille{histoire/eniac.eps}{0.9\hsize}
  
  \begin{itemizer}
  \item Tout manuel
  \item Ordinateur à relais, voire à lampe
  \item Langage binaire au mieux, câblage avec des fils standard
  \item Cartes perforées
  \item Applications numériques : génération de tables, balistique,...
  \item IBM 704 (1954) : nombres flottants
  \item Arriver à faire tourner 1 programme avant qu'un tube ne grille ou
    un \emph{bug} se coince dans un relai
  \item Jay \textsc{Forrester} \& Bob \textsc{Everett}, Whirlwind,
    simulateur temps réel à mémoire à tores, 500000~$+/$s,
    50000~$×/$s, \$32\,000 de tubes/mois (1951)
   \end{itemizer}
\end{trans}


\begin{trans}{1955--1965 : Jusqu'à l'OS}
  \begin{itemizer}
  \item Toujours qu'un seul utilisateur, réservation par tranche horaire
  \item Traitement par lots : faire la queue
  \item Mono-programmation
  \item 1957 : John \textsc{Backus} (IBM), langage \& compilateur Fortran
    \vavers $\nearrow$ \emph{vitesse de programmation}
  \item 1957 : Seymour \textsc{Cray}, CDC1604, supercalculateur tout
    transistor
  \item 1957 : Disque dur IBM 305 RAMAC ($\approx$ 2 réfrigérateurs)
  \item 1959 : Bull Gamma 60, instructions de parallélisme (parce que la
    mémoire était trop rapide par rapport au processeur !)
  \item Spécialisation des tâches pour optimiser globalement les coûts en
    utilisant plusieurs ordinateurs au lieu d'un seul plus gros ;
    \begin{itemizet}
    \item Petit IBM 1401 pour faire du transfert cartes perforées \vavers
      bandes magnétiques (données)
    \item Gros calcul sur IBM 7094
    \item Petit IBM 1401 pour faire du transfert bandes magnétiques
      \vavers imprimantes (données)
    \end{itemizet}
 \end{itemizer}
\end{trans}


\begin{trans}{1965--1985 : Multiprogrammation, temps partagés}
  \begin{itemizer}
  \item Gros systèmes
  \item Multiprogrammation : plusieurs programmes résident en mémoire
  \item Temps partagé : terminaux interactifs
  \item \emph{spool} : \emph{Simultaneous Peripheral Operation On Line} :
    on empile les requêtes d'impression et on fait autre chose
  \item Mémoire
    \begin{itemizet}
    \item Pagination : gestion plus fine simplifiée
    \item Segmentation : différents espaces d'adressage
    \end{itemizet}
  \item Technologie
    \begin{itemizet}
    \item Transistors puis circuits intégrés, micro-processeur $\equiv$
      brique de base de l'informatique
    \item Disques magnétiques $\nearrow$
    \item Mécanisme d'interruption
    \item Accès direct à la mémoire
    \item Écrans $±$ graphiques
    \item Modems
    \item « Grosses » mémoires
    \item Loi de Moore
    \end{itemizet}
  \item Projet MULTICS : \emph{MULTiplexed Information and Computing
      Service}
    \begin{itemizet}
    \item MIT, Bell Telephone Laboratories de AT\&T, General Electric
    \item Notion de « Computer Grid » (qui revient de nos jours...)
    \item Offrir puissance de calcul pour toute la ville de Boston : le
      Minitel avant l'heure
    \item Plus difficile que prévu \vavers{} abandonné mais grande
      influence dans la communauté
    \end{itemizet}
    \LienPDF{http://www.multicians.org/}
 \end{itemizer}
\end{trans}


\begin{trans}{Unix Story}
  \begin{itemizer}
  \item En attendant la suite, Ken Thomson de BTL écrit un jeu \emph{Space
      Travel} qu'il fait tourner sur un PDP-7 (machine pas trop chère)
  \item Problème : pas d'environnement de développement sur PDP-7 et
    nécessité de faire de l'assemblage croisé sur Honeywell 635 roulant
    GECOS
  \item Pour faciliter le développement du jeu, développement d'un système
    d'exploitation pour le PDP-7 : système de fichier simple
    (\emph{s5fs}), système de gestion de processus, interpréteur de
    commande (\emph{shell})
  \item Le système devient auto-suffisant et est nommé \emph{Unix} en
    1969, jeu de mots en opposition à \emph{Multics}
  \item Portage d'Unix sur PDP-11 et développement de l'éditeur de texte
    \texttt{ed} et du système de composition de texte \texttt{runoff}
  \item Développement de langage interprété \emph{B} utilisé pour
    développer les outils
  \item Dennis Ritchie fait évoluer le langage en \emph{C} dont le succès
    a largement dépassé le cadre d'Unix
  \item 1972 : 10 machines sous Unix...
  \item Unix réécrit en C en 1973 et la distribution version 4 contient
    elle-même \texttt{cc}
  \item L'université de Berkeley récupère une licence (gratuite à cause
    d'un procès antitrust de 1956 entre AT\&T et Western Electric
    Company)
  \item Travaux à SRI de Doug \textsc{Engelbart} sur interfaces graphiques
    dans les années 1960 repris ensuites chez Xerox \textsc{parc}
  \item La version 7 de 1979 est la première version réellement portable
  \item Beaucoup d'améliorations fournies par les utilisateurs eux-mêmes
    (de même que BSD \& Linux maintenant) favorisé par le côté non
    commercial
  \item MicroSoft et Santa Cruz Operation collabore sur un portage pour
    i8086 : Xenix
  \item Portage sur machine 32 bits (Vax-11) en 1978 : UNIX/32V qui est
    récupérée par Berkeley\\
    (\LienPDF{http://www.lpl.arizona.edu/~vance/www/vaxbar.html} VaxBar)
  \item Rajout d'utilitaires (\texttt{csh} de Bill Joy) et d'un système de
    pagination
  \item La DARPA donne un contrat à Berkeley pour implémenter IP : BSD
    \begin{itemizet}
    \item Dernière version en 1993 : 4.4BSD. En tout : apport des
      \emph{socket}, d'IP, d'un \emph{fast file system} (FFS), des signaux
      robustes, la mémoire virtuelle
    \item Société BSDI créée pour vendre 4.4BSD \emph{lite} en 1994,
      débarrassé de tout code d'origine AT\&T
    \end{itemizet}
  \item 1982 : loi antitrust qui éclate AT\&T en baby-Bell dont le AT\&T
    Bell Laboratories qui peut alors commercialiser Unix
    \begin{itemizet}
    \item 1982 : System III
    \item 1983 : System V
    \item 1984 : System V release 2 (SVR2)
    \item 1987 : System V release 3 (SVR3) introduit les IPC (InterProcess
      Communications : mémoire partagée, sémaphores), les \emph{STREAMS},
      le \emph{Remote File Sharing}, les bibliothèques partagées,...
    \item Base de nombreux Unix commerciaux
    \end{itemizet}
  \item 1982 : Bill Joy quitte Berkeley pour fonder Sun Microsystems.
    Adaptation de 4.2BSD en SunOS qui introduit le \emph{Network File
      System}, interface de système de fichier générique, nouveau
    mécanisme de gestion mémoire    
  \end{itemizer}
\end{trans}


\begin{trans}{1985-- : Micro-ordinateurs}
  \begin{itemizer}
  \item Montée en puissance du microprocesseur
  \item Micro-ordinateurs $\equiv$ ordinateur à base de microprocesseur :
    quasiment tout ordinateur
  \item Explosion du multi-fenêtrage \vavers{} interfaces plus
    sympathiques
  \item Gros ordinateur (parallèle) \vavers{} rassemblements de nombreux
    processeurs
  \item Apparition des systèmes distribués
  \item Stations de travail
  \item Généralisation des réseaux d'abord pour partager disques coûteux :
    NFS
  \item WWW devenu synonyme d'Internet 30 après
  \item 1981 : le premier PC
    \begin{itemizet}
    \item Grand retour en arrière (...pour les spécialistes) :
      mono-programmation : MS-DOS 1.0, PC-DOS 1.0
    \item Système de fichier primitif (...mais robuste), pas de
      répertoire,...
    \end{itemizet}
  \item Milieu des années 1980 à Carnegie-Mellon University développe
    Mach, un micro-noyau avec des serveurs implémentant une sémantique
    4BSD. OSF/1 \& NextStep sont basés sur Mach
  \item Steve Jobs crée NeXT Computer après avoir été écarté d'Apple
  \item 1987 Andrew Tanenbaum publie « \emph{MINIX: A UNIX Clone with
      Source Code for the IBM PC} »
    \LienPDF{http://www.cs.vu.nl/\string~ast/minix.html}
  \item 1987 : AT\&T achète 20\% de Sun \vavers{} prochaines version de
    SunOS basées sur System V : SunOS 5 (Solaris 2)
  \item NeXT Computer avec NeXTStep~0.8 (mélange de Mach~2.5 4.3BSD,
    interface graphique basée sur Display Postscript, programmation en
    Objective-C)
  \item 1989 : co-développement AT\&T-Sun de SVR4 : inclut les
    fonctionnalités de SVR3, 4BSD, SunOS \& Xenix. Création d'Unix Systems
    Laboratories pour développer et vendre Unix
  \item Tim Berners-Lee crée le premier brouteur WWW sur NeXT au CERN en
    1990
  \item Novell achète une partie d'USL en 1991 pour développer UnixWare
    (Unix + Netware) et tout USL en 1993
  \item Linus Torwald récupère Minix sur PC i80386 et le développe en
    Linux en 1991
    \LienPDF{http://www.dina.dk/\string~abraham/Linus\string_vs\string_Tanenbaum.html}
  \item NeXTStep~486 en 1992 
  \item 1994 : première version publique de Linux : 1.0. Développements
    pris en main par des programmeurs répartis sur Internet. Intégration
    des utilitaires GNU
  \item Arrivée de NT (\emph{New Technology}) : mélange de MS-DOS, MacOS,
    VMS et Unix
  \item Novell cède la marque Unix au X/Open puis Sun rachète les droits
    de SVR4 à Novell en 1994
  \item NeXT et Sun définisse OpenStep. Repris par la suite dans SunOS,
    HP-UX et NT en partie. Continue dans \LienPDF{http://www.gnustep.org}
  \item Chorus, société française, développe un micro-noyau
  \item Rachat de Chorus par Sun. \vavers{} JavaOS ?
  \item Un système Unix $\equiv$ programmes utilisateurs + bibliothèques +
    utilitaires + système d'exploitation qui fournit le support
    d'exécution et les services
  \item Unix tourne sur toutes les plates-formes depuis les systèmes
    embarqués jusqu'aux supercalculateurs massivement parallèles
  \item Mac OS X server sort en 1999 revampant NeXTStep et OpenStep
  \item 2000 : Windows 2000 : plus stable, plus gros. Exposé passionnant
    sur l'ingéniérie du projet dans «~From NT OS/2 to Windows 2000 and
    Beyond - A Software-Engineering Odyssey~»
    \LienPDF{http://www.usenix.org/events/usenix-win2000/invitedtalks}
  \item 2001 : Windows XP : encore plus stable, encore plus gros
  \item MacOS X 10.3 (Panther) en octobre 2003
    \LienPDF{http://www.kernelthread.com/mac/osx}
  \end{itemizer}
\end{trans}


\section{Concepts de base}


\begin{trans}{Concepts de base}
  \begin{itemizer}
  \item Multiprogrammation
  \item Temps partagé
  \item Pagination \& segmentation
  \end{itemizer}
\end{trans}


\begin{trans}{Multiprogrammation}
  \deuxcolonnes{%
    \begin{itemizer}
    \item \vavers{} Mieux utiliser processeur
    \item Partage la mémoire entre plusieurs processus
    \item Recouvrement du temps d'entrées-sorties avec du calcul
    \item Protection des programmes entre eux
    \end{itemizer}
    \psfiglarge{systemes_exploitation/multi-programmation.idraw}
    }
\end{trans}


\begin{trans}{Code translatable}
  \Attention{} Éviter des conflicts d'adresses entre programme
  \begin{itemizer}
  \item Ne pas figer (à la compilation) les adresses des objets manipulés
    par un programme, les bouts d'éxécutables (bibliothèques de
    fonctions,\ldots)
  \item Solutions possibles
    \begin{itemizet}
    \item Calculer les adresses au moment du chargement
    \item Utiliser un mécanisme matériel : adresse relative par rapport à
      une base
    \item Tout sous-traiter à une unité de traduction d'adresse
    \end{itemizet}
  \item La solution logicielle est tout de même utilisée pour
    \begin{itemizet}
    \item Compilation séparée : fusion de \texttt{.o} par édition de liens
    \item Bibliothèques dynamiques
    \item Chargement de code à la volée
    \item Compilation de code à la volée
      \begin{itemizec}
      \item $\exists$ Langages interprétés : JVM pour Java, PostScript,
        Forth, PERL, Python, SmallTalk, BibTeX,\ldots
      \item Accélération avec une phase de compilation préalable (JIT :
        \emph{Just In Time} compilation pour Java/JVM)
      \item Cache de code précompilé
      \end{itemizec}
    \item \Attention{} Virus par débordement de variables : arriver à
      écraser des données pour faire exécuter du code quelconque (Cf mon
      cours 3A IT~S301)
    \end{itemizet}
  \end{itemizer}
\end{trans}


\begin{trans}{Base et déplacement}
  \deuxcolonnes{%
    \begin{itemizer}
    \item Remplacer \texttt{*p} par \texttt{*(base + d)}
    \item Changer de place en mémoire : changer \texttt{base}
    \item Protection mémoire : vérifier toujours
      \[
      \mathtt{d} \in [0,\mathtt{d}_\mathrm{max}]
      \]
    Registres 
    $\left\{\begin{array}{l}
        \mathtt{base}=2000\\
        \mathtt{d}_\mathrm{max}=26
      \end{array}\right.$\\
    $\Longrightarrow 2000 \leq \mathtt{base} + \mathtt{d} \leq 2026$
  \item Typiquement dans processeur à mode d'adressage compliqué : CISC
    \end{itemizer}
    \psfiglarge{systemes_exploitation/base-deplacement.idraw}
    }
\begin{exemple}
8b 95 74 e3 ff ff       mov    0xffffe374(%ebp),%edx
\end{exemple}
sur $x86$, mais sans vérification des bornes
\end{trans}


\begin{trans}{Temps partagé -- tourniquet}
  \deuxcolonnes{%
    \begin{itemizer}
    \item Donner illusion de disposer d'une machine à soi tout seul
    \item Lié à l'invention du terminal interactif
    \item Changer de programme à chaque quantum de temps
    \item Privilégier les requêtes peu gourmandes par rapport aux
      programmes de calcul : faire des heureux facilement avec
      \emph{caisse moins de 10 Articles}
    \end{itemizer}
    \psfiglarge{systemes_exploitation/tourniquet_p1.ps}
    }
\end{trans}


\begin{trans}{Blocage dans le tourniquet}
  \deuxcolonnes{%
    \begin{itemizer}
    \item Blocage possible d'un processeur avant la fin de son quantum de
      temps
    \item Libère du temps pour les autres
    \end{itemizer}
    \psfiglarge{systemes_exploitation/tourniquet_p2_court.ps}
    }
\end{trans}


\begin{trans}{Pagination}
  \begin{itemizer}
  \item Mémoire trop petite pour contenir tout un programme
  \item \vavers{} Concept de mémoire virtuelle : fournir à l'utilisateur
    une mémoire géante
  \end{itemizer}
  \deuxcolonnes{%
    \begin{itemizer}
    \item Casser la mémoire physique en pages
      \begin{itemizet}
      \item Rajouter composant de traduction entre mémoire virtuelle et
        mémoire physique : \emph{Memory Management Unit}
      \item Programmes utilisent des adresses virtuelles
      \item Page de mémoire virtuelle
        \begin{itemizec}
        \item Soit mémoire physique
        \item Soit en mémoire de masse (sur disque dur)
        \item Soit inexistante
        \end{itemizec}
      \end{itemizet}
      \psfiglarge{systemes_exploitation/pagination.idraw}
    \end{itemizer}%
    }
  \begin{itemizer}
  \item Fonctionne bien avec le principe de multiprogrammation : si une
    page n'est pas là, exécute un autre programme en attendant son
    chargement
  \end{itemizer}
\end{trans}


\begin{trans}{Segmentation}
  \begin{itemizer}
  \item Programme, système, applications : non monolithiques
    \deuxcolonnes{%
    \begin{itemizet}
    \item Modules
    \item Couches
    \item Objets
    \item ...
    \end{itemizet}
    \vavers{} Segments de mémoire indépendants
    \psfiglarge{systemes_exploitation/segments.idraw}
    }
  \item Addressage propre à chaque segment : permet de croître
    arbitrairement sans conflit (une baguette n'a que 2 croûtons\ldots
    \frownie)
    \begin{itemizet}
    \item Segment pour la pile
    \item Segment pour le code
    \item Segment pour des données globales
    \item Segment pour le système d'exploitation
    \item Segment pour les \verb/new Carottes()/
    \item Segment pour les \verb/new Lapin()/
    \item \ldots
    \end{itemizet}
  \item Protection spécifique à chaque segment : lecture, écriture,
    exécution
  \item Moins fondamental avec grands espaces d'adressage sur 64~bits
  \item Reste des scories dans $x86$ qui ont repris le mode d'adressage du
    Mitra~15 (i8086) puis du Mitra~125 (386) de CII avec les mêmes noms
    !\\
    \texttt{DS}, \texttt{ES}, \texttt{CS},\ldots
  \end{itemizer}
\end{trans}


\section{Concurrence \& Parallélisme}

\subsection{Introduction}


\begin{trans}{Concurrence et parallélisme}
  \begin{itemizer}
  \item Applications \& algorithmes complexes avec des choses
    indépendantes
  \item Simplification de la programmation : détacher les tâches les unes
    des autres
  \item Gestion explicite des tâches
    \begin{itemizet}
    \item Co-routines
    \item \texttt{setjmp()}/\texttt{longjmp()}
    \item Gestion à la main... \frownie
    \end{itemizet}
  \item Si plusieurs processeurs : possibilité d'exécuter plusieurs tâches
    en parallèle
  \end{itemizer}
\end{trans}


\begin{trans}{Tâches}
  \begin{itemizer}
  \item Besoin de simplification de la programmation (productivité)
  \item Abstraction de la notion de tâche
    \begin{itemizet}
    \item Programme s'exécutant (actif) sur un processeur virtuel \vavers
      processus (lourd) dans Unix
    \item Contexte d'exécution : ressources virtuelles (espace mémoire,
      fichiers...)
    \item Atomicité possible (transactions...)
    \end{itemizet}
  \item Gestion directe par le système d'exploitation
  \end{itemizer}
\end{trans}


\subsection{Hypothèses sur architecture matérielle}


\begin{trans}{Schéma d'un monoprocesseur}
  \psfiglarge{systemes_exploitation/monoprocesseur.idraw}
  \begin{itemizer}
  \item Unité centrale : interprète instructions des programmes
    applicatifs et du système d'exploitation
  \item Unités d'échange (contrôleur, canal) : assurent le suivi des
    entrées-sorties
  \item Mémoire : accessible via le bus par unité centrale et unités
    d'échange\\
    Pour décharger le processeur : accès directe à la mémoire par unités
    d'échange
    \belleboite{\emph{Direct Memory Access} (DMA)}
  \end{itemizer}
\end{trans}


\begin{trans}{Mécanisme d'interruptions}
  Besoin de surveiller et réagir

  \belleboite{Comment éviter de passer son temps à surveiller les E/S ?}

  Interruption $\equiv$ événement prioritaire qui interrompt déroulement
  normal d'un programme en cours d'exécution sur une unité centrale

  \psfiglarge{systemes_exploitation/interruption.idraw}

  \psfiglarge{systemes_exploitation/interruptions.idraw}

  Types d'interruptions :
  \begin{itemizer}
  \item Externes : matérielles\\
    Déclenchées par du matériel externe : horloge, clavier, réseau,
    entrée-sortie, fin de ligne vidéo, panne de courant,...
  \item Internes : interruptions logicielles, déroutement\\
    Instruction de passage dans le noyau, division par 0, instruction
    inexistante, instruction non autorisée, accès mémoire invalide,...
  \end{itemizer}
  Le concept équivalent d'interruption existe au niveau logiciel : signaux
  Unix $\equiv$ fonction (\emph{handler}) exécutée sur certaines
  conditions (erreur, communication possible,...),...
\end{trans}


\begin{trans}{Mécanisme d'interruptions --- détail}
  \begin{itemizer}
  \item Contexte matériel : registres à sauvegarder quand survient une
    interruption
    \begin{itemizet}
    \item Compteur ordinal
    \item Sommet de pile de programme
    \item Mot d'état du programme
    \item État du pipeline interne
    \end{itemizet}
    Dépend du processeur
  \item Possibilité de masquer les interruptions\\
    Éventuellement automasquage pour éviter récursion infinie
  \item Niveaux (priorités) d'interruptions\\
    Parer au plus urgent
  \item Structure de pile pour accepter un nombre arbitraire
    d'interruptions en cours
  \end{itemizer}
\end{trans}


\begin{trans}{Schéma d'un multiprocesseur}
  Mémoire commune
  \psfiglarge{systemes_exploitation/multiprocesseur.idraw}
  \begin{itemizer}
  \item Plusieurs unités centrales pour augmenter la puissance :
    interprètent instructions des programmes applicatifs et du système
    d'exploitation
  \item Mémoire : plusieurs bancs pour augmenter taille et débit
  \end{itemizer}
\end{trans}


\begin{trans}{Interruptions \& multiprocesseur}
  Hypothèses :
  \begin{itemizer}
  \item Chaque processeur peut masquer localement les interruptions
  \item Interruption matérielle aiguillée vers processeur
    \begin{itemizet}
    \item Ne masquant pas interruptions
    \item Si possible celui exécutant le processus de plus faible priorité
    \end{itemizet}
  \end{itemizer}
\end{trans}


\begin{trans}{Classes d'architectures matérielles}
  \begin{itemizer}
  \item Architectures centralisées
    \begin{itemizet}
    \item Monoprocesseurs
    \item Multiprocesseurs à mémoire partagée
    \end{itemizet}
  \item Architectures réparties
    \begin{itemizet}
    \item Multiprocesseurs à mémoire distribuée : communication par messages
    \item Réseaux
    \end{itemizet}
  \end{itemizer}
\end{trans}


\subsection{Notion de noyau}


\begin{trans}{Notion de noyau}
  \begin{itemizer}
  \item Couche de logiciel, voire de matériel
  \item Met en \oe{}uvre le concept de processus
  \item Tourne dans une machine physique ou virtuelle
  \end{itemizer}
\end{trans}


\begin{trans}{Noyau Unix}
  Plus qu'un noyau minimal : presque tout le système d'exploitation
  \begin{itemizet}
  \item Gestion mémoire
  \item Systèmes de gestion de fichiers
  \item Entrées-sorties de bas niveau
  \item Entrées-sorties de haut niveau
  \item Sécurité
  \item ...
  \end{itemizet}
  Mais évolution vers des Unix modulaires...
\end{trans}


\begin{trans}{Notion de micro-noyau}
  \psfiglarge{systemes_exploitation/micro-noyau.idraw}
\end{trans}


\begin{trans}{Mises en \oe{}uvres de la concurrence}
Faire tourner plusieurs choses
  \begin{itemizer}
  \item Sur machine nue
    \begin{itemizet}
    \item Système d'exploitation lui-même
    \item Application de contrôle de procédé, temps réel « dur »
    \end{itemizet}
  \item Sur machine virtuelle (qui permet la concurrence)
    \begin{itemizet}
    \item Temps réel : émulation d'un système d'exploitation sur un autre
      système d'exploitation
    \item Temps simulé : simulation numérique, prévision
      météorologique,...
    \end{itemizet}
  \end{itemizer}
  Dans la suite on se focalise sur concurrence et systèmes d'exploitation
\end{trans}


\begin{trans}{Fonctions d'un micro-noyau}
  \begin{itemizer}
  \item Partager le ou les processeurs entre les processus
  \item Gérer naissance et mort des processus
  \item Cacher les interruptions (entrées-sorties et horloge)
  \item Fournir un service d'entrées-sorties de bas niveau
  \item Fournir outils d'exclusion mutuelle, de synchronisation et de
    communication inter-processus
  \end{itemizer}
\end{trans}


\begin{trans}{Noyau et interface de programmation}
  \psfiglarge{systemes_exploitation/noyau-interface-programmation.idraw}
\end{trans}


\begin{trans}{Structure Unix traditionnel (ab initio)}
  \psfiglarge{systemes_exploitation/structure-unix.idraw}
\end{trans}


\begin{trans}{Séparer politique et mécanisme}
  \psfiglarge{systemes_exploitation/noyau-clients-serveurs.idraw}

  \belleboite{Mécanisme de clients-serveurs autour d'un bus logiciel}
\end{trans}


\begin{trans}{Structure Unix moderne}
  \psfiglarge{systemes_exploitation/structure-unix-moderne.idraw}
\end{trans}


\begin{trans}{Centralisation contre distribution}
  2 types de systèmes
  \begin{itemizer}
  \item Systèmes centralisés : 1 seul noyau
    \begin{itemizet}
    \item Monoprocesseur
    \item Multiprocesseur à mémoire partagée
    \end{itemizet}
  \item Systèmes distribués ou réseau : autant de noyau que de processeurs
    \begin{itemizet}
    \item Multiprocesseur sans mémoire commune
    \item Réseaux d'ordinateurs, stations de travail
    \end{itemizet}
  \end{itemizer}
\end{trans}


\begin{trans}{Systèmes distribués}
  \psfiglarge{systemes_exploitation/systeme-distribue-reseau.idraw}
  
  Autant de noyaux que de machines (qui peuvent être des multiprocesseurs
  à mémoire partagée...)
\end{trans}


\begin{trans}{Quand donner contrôle au noyau ?}
  \begin{itemizer}
  \item Quand un processus actif appelle une fonction système (du noyau)
    \begin{multicols}{2}
      \begin{itemizet}
      \item Créer un processus
      \item Attendre la fin d'un processus
      \item Indiquer que l'on a terminé
      \item Se bloquer en attente d'un événement
      \item Demander une entrée-sortie de bas niveau
      \item Attendre un certain temps
      \item Envoyer un message
      \item Recevoir un message
      \end{itemizet}
    \end{multicols}
  \item Quand une interruption matérielle survient
  \end{itemizer}
\end{trans}


\begin{trans}{Informations gérées par le noyau}
  \begin{itemizer}
  \item Données globales au noyau (temps, mémoire,...)
  \item Connaît tous les processus (table des processus)
  \item Descripteur de chaque processus
    \begin{itemizet}
    \item Contexte matériel
    \item Une partie du contexte logiciel
    \end{itemizet}
  \item Gère transitions entre états des processus
  \end{itemizer}
\end{trans}


\begin{trans}{Graphe des états d'un processus}
  \psfiglarge{systemes_exploitation/graphe-etats-processus.idraw}
\end{trans}


\begin{trans}{Graphe des états d'un processus sous Unix}
  \psfiglarge{systemes_exploitation/graphe-etats-processus-unix.idraw}
\end{trans}


\begin{trans}{Atomicité des actions noyau}
  \begin{itemizer}
  \item De nombreuses actions concurrentes dans le système : mise à jour
    liste processus, modification entrées-sorties à faire,...
  \item \vavers{} Besoin d'assurer cohérence des informations gérées par
      le noyau
  \item Utilisation de l'exclusion mutuelle
    \begin{itemizet}
    \item Mono-processeur : masquage des interruptions
    \item Multiprocesseur à mémoire commune : masquage des interruptions
      et construction de verrous avec des instructions spéciales
      insécables (\emph{test and set}, \texttt{swap}, \texttt{XRM},...)
    \end{itemizet}
  \end{itemizer}
  \Attention{} Il y a aussi les dispositifs d'échange qui peuvent modifier
  la mémoire...
\end{trans}


\begin{trans}{Contexte matériel}
  \begin{itemizer}
  \item Processus arrêtés lorsqu'une interruption matérielle ou logicielle
    survient
  \item Sauvegarde (minimale) des registres de la machine nécessaires au
    (re)fonctionnement d'un processus
    \begin{itemizet}
    \item Registres de travail
    \item Compteur ordinal (pointe instruction courante)
    \item Mot d'état du programme (bits de protection, résultats
      d'opération)
    \item Pointeur de pile
    \item Éventuellement état du pipeline sur processeur complexes,...
    \end{itemizet}
  \end{itemizer}
\end{trans}


\begin{trans}{Sauvegarde et restitution de contexte}
  Comment modifier l'exécution des processus ?
  \psfiglarge{systemes_exploitation/sauvegarde-restitution-contexte.idraw}

  \begin{enumerate}
  \item P1 actif
  \item Une interruption survient. Les registres de la machine sont
    sauvegardé dans une zone mémoire (selon le processeur, cela peut aussi
    être un jeu de registres supplémentaire). Passage en mode superviseur
  \item Le noyau s'exécute
  \item Le noyau fait une copie de cette zone dans le descripteur du
    processus P1 (contexte matériel)
  \item Le noyau choisit de rendre le processus P2 actif. Il copie le
    contenu du contexte matériel du processus P2 dans la zone mémoire
  \item L'instruction de retour sur interruption copie la zone mémoire
    dans les registres du processeur
  \item P2 commence/continue sa vie
  \end{enumerate}
\end{trans}


\begin{trans}{Appel système}
  \psfiglarge{systemes_exploitation/appel-systeme.idraw}
\end{trans}


\begin{trans}{Appel moniteur/BIOS}
  Certains systèmes ont une couche d'abstraction matérielle supplémentaire
  \begin{itemizer}
  \item Portabilité accrue : \emph{Basic Input/Output System}
    \textsc{bios} sur \Apc) pour accéder aux ressources d'un \Apc sans
    faire appel à des programmes sur disque \vavers contenu en mémoire
    permanente (\Arom, Flash)
  \item Possibilité de debug, variables d'environnement (Sun)
  \item Des cartes d'entrées-sorties peuvent rajouter des fonctionnalités
  \end{itemizer}
\begin{exemple}
void point(int x,int y) {
  _CX = x ;
  _DX = y ;
  _AL = couleur ;
  _AH = 0x0C ;
  geninterrupt(0x10) ;          /* Fonction 0Ch de l'int. 10h */
}
\end{exemple}
\end{trans}


\begin{trans}{Entrée et sortie du noyau}
  \begin{itemizer}
  \item Entrée
    \begin{itemizet}
    \item Sauvegarde du contexte matériel
    \item Passage en mode superviseur/noyau
    \item Masquage local des interruptions
    \item Si multiprocesseur, prélude de boucle d'attente active (avec
      \emph{test \& set}, \texttt{XRM},...) sur certaines structures du
      noyau
    \end{itemizet}
  \item Sortie
    \begin{itemizet}
    \item Si multiprocesseur, postlude d'exclusion mutuelle
    \item Démasquage local des interruptions
    \item Restitution du contexte matériel et passage en mode
      utilisateur/esclave
    \end{itemizet}
  \end{itemizer}
\end{trans}


\begin{trans}{Contexte logiciel d'un processus}
  Regroupe
  \begin{itemizer}
  \item Ce que le noyau a besoin de savoir sur le processus
    \begin{itemizet}
    \item Minimal si micro-noyau
    \end{itemizet}
  \item Ce que le reste du système d'exploitation a besoin de savoir
    \begin{itemizet}
    \item Si processus léger (\emph{thread}) : peu de choses
    \item Processus lourds beaucoup de choses :
      \begin{itemizec}
      \item Gestion des processeurs
      \item Gestion de la mémoire
      \item Gestion des fichiers
      \end{itemizec}
    \end{itemizet}
  \end{itemizer}
  \Attention{} Sous Unix, système et noyau ne font qu'un...
\end{trans}


\subsection{Processus lourds \& légers, \protect\emph{threads}}


\begin{trans}{Vie et mort d'un processus}
  \psfiglarge{systemes_exploitation/vie-mort-processus.idraw}
\end{trans}


\begin{trans}{Préemption dans le noyau}
  \begin{itemizer}
  \item Plusieurs tâches concurrentes dans le noyau, voire parallèles si
    plusieurs processeurs
  \item Interruptions asynchrones
  \item Préemption en standard dans noyau Linux 2.6 : tâches du noyau
    peuvent être aussi interrompues
  \item Meilleure réactivité... \smiley
  \item ...source de bugs améliorée \frownie
  \item Bien soigner partage de ressources pour éviter interblocages
  \item Ne pas tomber dans excès inverse d'avant 2.6 : gros
    \texttt{cli}/\texttt{sti}
  \end{itemizer}
\end{trans}


\begin{trans}{Synchronisation \& concurrence}
  \begin{itemizer}
  \item Application utilisateur
    \begin{itemizet}
    \item Si application mono-thread pas de problème de partage de ressource
    \item Si multithread/multiprocessus, possibilité de conflits d'accès à
      des ressources, interblocages,...
    \item \vavers{} Utilisation de primitives atomiques : verrous,...
    \item Dans le pire des cas, arrêt des tâches possibles
    \end{itemizet}
  \item Tâche dans le noyau
    \begin{itemizet}
    \item Intrinsèquement multitâche
    \item \vavers{} Utilisation de primitives atomiques : verrous,...
    \item Pas de système d'exploitation pour veiller...
    \item ... Si conflits d'accès ou étreintes mortelles : plantage du
      système \frownie
    \end{itemizet}
  \end{itemizer}
\end{trans}


\begin{trans}{4 états d'exécution possible}
  \begin{itemizer}
  \item Un processus lourd ou léger en cours d'exécution en mode
    utilisateur
  \item Un processus lourd ou léger en cours d'exécution en mode
    noyau
  \item Une tâche noyau en cours d'exécution
  \item Mode interruption dans noyau
  \end{itemizer}  
\end{trans}


\begin{trans}{Vie et mort d'un processus version Unix}
  \psfiglarge{systemes_exploitation/vie-mort-processus-unix.idraw}
  \begin{itemizer}
  \item \texttt{fork()} crée un clone du père
    \begin{itemizet}
    \item Ne partagent que les valeurs initiales
    \end{itemizet}
  \item Souvent suivi d'un \texttt{exec()} pour exécuter un autre
    programme dans le processus
    \begin{itemizet}
    \item En fait optimisation de \texttt{fork()}: partage des pages de
      mémoire et copie seulement lors de la première écriture
      (\textsc{cow} \emph{Copy On Write})
    \item Par le passé pré-\textsc{cow}, introduction du \texttt{vfork()}
      \textsc{bsd} optimisé pour un \texttt{exec()} : le fils
      \emph{utilise} l'espace mémoire du père qui est rendu après
      l'\texttt{exec()}... mais appel système toujours présent
    \end{itemizet}
  \end{itemizer}  
\end{trans}


\begin{trans}{Distinguer le père du fils en Unix ?}
  Clones parfaits pas toujours utiles \vavers{} brisure de symétrie
  \begin{alltt}
{\red/* Code du père */}
resultat = fork();
/* Code du père ET du fils */
if (resultat < 0) \{
  {\red perror("Le fork() s'est viandé grave :-( !");}
  {\red exit(2002);}
\}
if (resultat == 0) \{
  {\orange /* Je suis le fils */}
  {\orange if (execve("/un/autre/programme") < 0) \{}
    {\orange perror("L'exec() dans le fils n'a pas marché !");}
    {\orange exit(2003);}
  {\orange \}}
  {\yellow /* On n'exécutera jamais ici. */}
\}
else \{
  {\red /* Je suis le père et resultat contient le numéro du fils */}
  {\red ...}
\}
  \end{alltt}
\end{trans}


\begin{trans}{Contexte logiciel processus lourd UNIX}
  \begin{itemizer}
  \item État du processus (stoppé, activable,...)
  \item Date de lancement du processus
  \item Temps unité centrale utilisé
  \item Identificateur du processus (PID \emph{process identification})
  \item Identificateur du père du processus
  \item Pointeur sur le segment de code (les instructions)
  \item Pointeur sur le segment des variables globales (initialisées à 0)
  \item Pointeur sur le segment BSS (variables pré-initialisées par le
    programmeur)
  \item Table (de bits) des signaux en attente
  \item Identité du propriétaire-utilisateur UID (\emph{user
      identification}) réel, UID effectif (droits temporaires empruntés à
    un utilisateur)
  \item Identité du groupe GID (\emph{group identification}) réel, GID
    effectif (droits temporaires empruntés à un groupe)
  \item Droits d'accès par défaut sur les fichiers crées (masque UMASK)
  \item Répertoire de travail courant
  \item Répertoire racine (vision du monde changeable pour enfermer des
    processus : sécurité, test,...)
  \item Descripteurs (objet) des fichiers manipulés par le processus 
  \end{itemizer}
\end{trans}


\begin{trans}{Contexte logiciel UNIX en 2 parties}
  Pour des raisons d'optimisation mémoire centrale, division du contexte
  d'un processus :
  \begin{itemizer}
  \item \emph{U area} informations utiles lorsque le processeur
    est actif\\
    \vavers{} peuvent être stockées sur disque lorsque le processus ne
    tourne pas
  \item \emph{Proc area} informations indispensables au noyau en permanence
  \end{itemizer}
  \Attention{} Commandes d'information sur les processus (\texttt{ps},
  \texttt{top},...) peuvent provoquer du \emph{swap} car besoin d'accéder
  à l'\emph{U area}
\end{trans}


\begin{trans}{Espace virtuel des processus UNIX}
  Chaque processus lourd UNIX possède un espace d'adressage (virtuel)
  propre
  \begin{center}
    \begin{tabular}{|c|l}
      \hline
      Pile & Haut de la mémoire\\\cline{1-1}
      $\downarrow$\\
      \\
      $\uparrow$\\
      Tas\\\cline{1-1}
      Données globales\\\cline{1-1}
      BSS\\\cline{1-1}
      Code\\\cline{1-1}
      Page 0 & Bas de la mémoire (0)\\\hline
    \end{tabular}
  \end{center}
  \begin{itemizer}
  \item Besoin d'une convention (collective) de bon usage et programmation
  \item Pile contient au départ arguments de\\
\begin{verbatim}
int main(int argc, char *argv[], char *environ[])
\end{verbatim}
    \begin{itemizet}
    \item Les \texttt{argc} paramètres \texttt{argv} de la ligne de
      commande
    \item Variables d'environnement dans \texttt{environ}
    \item BSS données initialisées
    \item Données globales initialisées à 0
    \item Tas utilisé pour les variables allouées par \texttt{malloc()} ou
      \texttt{new}
    \item Code d'un programme (lecture seule) partageable par plusieurs
      processus
    \item Chasse au bugs : la page 0 ne contient pas de mémoire : permet
      de déclencher les erreurs d'accès \texttt{*(NULL)}
    \end{itemizet}
  \end{itemizer}
\end{trans}


\begin{trans}{Communications inter-processus sous UNIX}
  \begin{itemizer}
  \item \texttt{fork()} crée un clone du père
    \begin{itemizet}
    \item Ne partagent que les valeurs initiales
    \item En fait optimisation : partage des pages de mémoire et copie
      seulement lors de la première écriture
    \end{itemizet}
  \item Par construction espaces d'adressages propres et étanche
    \begin{itemizet}
    \item Pas de données partagées par défaut \vavers{} un peu plus
      complexe pour communiquer
    \item Communications par fichiers (à protéger avec des verrous). Ex.
      courrier entre facteur et lecteur de courrier\\
\begin{exemple}
int fcntl(int fd, int cmd, struct flock *lock);
\end{exemple}
    \item Communication par messages (\emph{pipe}, \emph{socket},...). Ex.
      envoi de courrier et entre facteurs
\begin{exemple}
int socket(int domain, int type, int protocol);
int pipe(int filedes[2]);
int socketpair(int domain, int type, int protocol, int sv[2]);
\end{exemple}
    \item IPC (\emph{InterProcess Communication}) : sémaphores, mémoire
      partagée,...
    \end{itemizet}
  \end{itemizer}
\end{trans}


\begin{trans}{Processus légers}
  \begin{itemizer}
  \item Besoin de concurrence plus fine dans un programme
  \item Processus lourd peut contenir plusieurs fibres d'exécutions
    (\emph{threads of execution}, processus légers)
  \item Partagent au sein d'un processus lourd Unix
    \begin{itemizet}
    \item Mémoire (données globales)
    \item Fichiers
    \item Signaux
    \item Données internes au noyau (état processeur,...)
    \end{itemizet}
  \item Mais les threads disposent en propre
    \begin{itemizet}
    \item Numéro (\emph{thread-id})
    \item Contexte matériel : image des registres de la machine (compteur
      ordinal, pointeur de pile,...)
    \item Pile
    \item Masque de signaux UNIX
    \item Priorité
    \item Mémoire locale via le tas global et la pile
  \end{itemizet}
  \end{itemizer}
\end{trans}


\begin{trans}{Vie et mort d'un processus version thread}
  Thread POSIX
  \psfiglarge{systemes_exploitation/vie-mort-processus-thread.idraw}
\end{trans}


\begin{trans}{Threads POSIX}
  \begin{itemizer}
  \item Créer un \emph{thread}
\begin{verbatim}
int pthread_create(pthread_t *thread, 
                   const pthread_attr_t *attr = null,
                   void *(*entry) (void *), 
                   void *arg)
\end{verbatim}
    \texttt{entry} indique la fonction à exécuter avec les paramètres
    \texttt{arg}
  \item Pour terminer
\begin{verbatim}
void pthread_exit(void *status)
\end{verbatim}
    Transmet dans \texttt{status} une cause de terminaison
  \item Attendre la fin d'un fils \emph{thread}
\begin{verbatim}
int pthread_join(pthread_t *thread ,  
                 void **status) ;
\end{verbatim}
    Récupère dans \texttt{status} une information sur la cause de la
    terminaison
  \end{itemizer}
\end{trans}


\begin{trans}{Threads utilisateurs dans un processus}
  \psfiglarge{systemes_exploitation/threads-dans-processus.idraw}
\end{trans}


\begin{trans}{2 niveaux d'ordonnanceur}
  Où choisir de multiplexer exécution concurrente ?
  \psfiglarge{systemes_exploitation/ordonnanceur-lourd-leger.idraw}
  \begin{itemizer}
  \item Ordonnanceur du noyau : processus plutôts lourds
  \item Ordonnanceur utilisateur dans chaque processus lourds :
    \emph{threads} plutôt légères\\
    \Attention blocages sur E/S... \frownie
  \end{itemizer}
\end{trans}


\begin{trans}{Avec ordonnanceur de threads noyau}
  \psfiglarge{systemes_exploitation/ordonnanceur-threads-noyau.idraw}
\end{trans}


\begin{trans}{Les processus légers dans Linux}
  \begin{itemizer}
  \item Pas de gestion spécifique dans Linux (contrairement à Solaris
    (\textsc{lwp}) ou Windows)
  \item Processus léger $\equiv$ processus lourd comme un autre... où on
    précise qu'on partage certaines choses (mémoire,...)
  \item Suppose que processus gérés de manière naturellement « légère »
    (création, changement de contexte,...)
  \item Si pas suffisant, utiliser une bibliothèque niveau utilisateur
  \end{itemizer}
\end{trans}

\begin{trans}{Quid entre processus lourd et léger ?}
\begin{exemple}
int clone(int (*fn)(void *), void *child_stack, int flags, void *arg);
\end{exemple}
  Linux propose appel système \texttt{clone()} permettant de choisir ce
  qui est partagé
  \begin{itemizet}
  \item Espace mémoire
  \item Descripteurs de fichiers (fichiers ouverts)
  \item Gestion des signaux
  \item Espace de nommage du système de fichiers
  \end{itemizet}
\end{trans}


\begin{trans}{Processus et threads : combien ça coûte ?}
  Dans une vieille version de Solaris (2.4) sur un vieux Sun
  \begin{center}
    \begin{tabular}{|l|r|r|}
      \cline{2-3}
      \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{\emph{Temps de création}} & \multicolumn{1}{c|}{\emph{Synchro sémaphore}}\\\hline
    \emph{User thread} & 52 $\mu$s & 66 $\mu$s\\\hline
    LWP & 350 $\mu$s & ? 390 $\mu$s\\\hline
    Processus & 1700 $\mu$s & 200 $\mu$s\\\hline
    \end{tabular}
  \end{center}
  Compromis d'utilisation
\end{trans}


\begin{trans}{Des processus sans système d'exploitation ?}
  \begin{itemizer}
  \item Processus et concurrence $\equiv$ concept de programmation
    important
  \item Difficile de porter tous les SE sur toutes les plateformes
    \frownie
  \item Pour des systèmes embarqués, pas toujours les ressources pour :
    microcontrôleur minuscule,...
  \item Idée si on ne veut pas écrire des co-routines à la main : traduire
    (compiler) les appels systèmes thread POSIX du programme en programme
    qui gère les tâches à la main dans espace utilisateur
  \item Génère un programme C séquentiel compilable par un compilateur C
    pour n'importe quoi
    \begin{itemizet}
    \item \emph{Atomic execution block} (AEB)
    \item séparés par du code qui gère le choix des AEB à exécuter
    \end{itemizet}
  \item Alexander G. \textsc{Dean}. \emph{Compiling for concurrency:
      Planning and performing software thread integration}. In
    \emph{Proceedings of the 23rd IEEE Real-Time Systems Symposium},
    Austin, TX, Dec 2003.
  \item \emph{Lightweight Multitasking Support for Embedded Systems using
      the Phantom Serializing Compiler}, André C. \textsc{Nácul} and Tony
    \textsc{Givargis}, DATE2005
  \end{itemizer}
\end{trans}


\subsection{\relax{} Plus de détail des tâches dans Linux}


\begin{trans}{Différents usages de clone()}
  \begin{itemizer}
  \item \LinuxFuncDecl{sys\_fork}{arch/i386/kernel/process.c}
\begin{lstlisting}
asmlinkage int sys_fork(struct pt_regs regs)
{
  return do_fork(SIGCHLD, regs.esp, &regs, 0, NULL, NULL);
}
\end{lstlisting}
  \item \LinuxFuncDecl{sys\_vfork}{arch/i386/kernel/process.c}
\begin{lstlisting}
asmlinkage int sys_vfork(struct pt_regs regs)
{
  return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs.esp, &regs, 0, NULL, NULL);
}
\end{lstlisting}
  \item \LinuxFuncDecl{sys\_clone}{arch/i386/kernel/process.c}
\begin{lstlisting}
asmlinkage int sys_clone(struct pt_regs regs)
{
  unsigned long clone_flags;
  unsigned long newsp;
  int __user *parent_tidptr, *child_tidptr;

  clone_flags = regs.ebx;
  newsp = regs.ecx;
  parent_tidptr = (int __user *)regs.edx;
  child_tidptr = (int __user *)regs.edi;
  if (!newsp)
          newsp = regs.esp;
  return do_fork(clone_flags, newsp, &regs, 0, parent_tidptr, child_tidptr);
}
\end{lstlisting}
  \end{itemizer}
  Le vrai boulot : \LinuxFuncDecl{do\_fork}{kernel/fork.c}
\begin{lstlisting}
long do_fork(unsigned long clone_flags,
	     unsigned long stack_start,
	     struct pt_regs *regs,
	     unsigned long stack_size,
	     int __user *parent_tidptr,
	     int __user *child_tidptr)
{
  struct task_struct *p;
  long pid = alloc_pidmap();
  ...
  p = copy_process(clone_flags, stack_start, regs, stack_size, parent_tidptr, child_tidptr, pid);
   ...
  if (!(clone_flags & CLONE_STOPPED))
          wake_up_new_task(p, clone_flags);
  else
          p->state = TASK_STOPPED;
  if (clone_flags & CLONE_VFORK)
          wait_for_completion(&vfork);
  return pid;
}
\end{lstlisting}
  \begin{itemizet}
  \item Le fils est réveillé : essaye de le faire tourner avant le père
    pour optimiser le \textsc{cow} en cas d'\texttt{exec()} rapide
  \item \verb|copy_process()| fait un \verb|dup_task_struct(current)| et
    initialise la structure de la tâche
  \end{itemizet}
\end{trans}


\begin{trans}{Tâches noyau}
  \begin{itemizer}
  \item Même le noyau peut avoir besoin de processus pour faire des choses
    de manière concurrente
  \item \vavers tâches noyau (convention de nommage : tâche comme
    raccourci de processus noyau)
  \item Création ? Comme les processus utilisateurs
    \begin{itemizet}
    \item Si processus utilisateur, création de processus utilisateur avec
      \texttt{clone()} ou (\texttt{v})\texttt{fork}
    \item Si tâche noyau, \texttt{clone()} crée une tâche noyau\\
      Exemple du chargement dynamique de module (si rajout de
      périphériques,...)%\\
      %Exemple de \LinuxFile{kernel/kthread.c},
      %\LinuxFile{kernel/workqueue.c}
\iffalse
\begin{exemple}
static struct task_struct *
  create_workqueue_thread(struct workqueue_struct *wq,
			  int cpu)
{
  ...
  p = kthread_create(worker_thread, cwq, "%s/%d", wq->name, cpu);
}
\end{exemple}
\fi
    \end{itemizet}
    Remarques
    \begin{itemizec}
    \item \Attention Un processus utilisateur ne peut créer que des
      processus utilisateurs... Si besoin tâche noyau : modifier le noyau
      ou mettre dans un module
    \item \Attention Une tâche noyau n'a aucun mode de protection, accède
      à toutes les ressources,... Sans filet !
    \end{itemizec}
  \end{itemizer}
\end{trans}


\begin{trans}{Exemple de liste de processus}
  \begin{itemizer}
  \item Outils \texttt{ps}, \texttt{top},...
\begin{exemple}
keryell@an-dro:~$ ps augxww
UUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.0   1584    80 ?        S    04:46   0:00 init [5]
root         2  0.0  0.0      0     0 ?        SN   04:46   0:00 [ksoftirqd/0]
root         3  0.0  0.0      0     0 ?        S<   04:46   0:00 [events/0]
root      2141  0.0  0.0   2984   176 ?        Ss   04:46   0:00 /sbin/klogd
bind      2171  0.0  0.1  29740   736 ?        Ssl  04:46   0:00 /usr/sbin/named -u bind
...
keryell   9620  0.0  0.1   4612   904 pts/4    R+   08:52   0:00 ps augxww
\end{exemple}
%$
\item Des entrées dans \texttt{/proc} pour chaque processus dont
  \emph{self}
  \end{itemizer}
\end{trans}

\begin{trans}{Représentation des tâches en interne}
  \begin{itemizer}
    \item Chaque processus est représenté par une
      \LinuxDecl{task\_struct}{include/linux/sched.h} de 1,7~Ko sur
      ordinateur 32~bits
    \item Contient tout ce que le noyau a besoin de connaître sur un
      processus pour le faire fonctionner
      \begin{itemizet}
      \item État (bloqué ou pas)
      \item Espace mémoire
      \item Exécutable associé
      \item Parenté
      \item Droits, capacités
      \item Fichiers ouverts
      \item Espace de nommage (montages particuliers, autre racine,...)
      \item Domaines d'exécutions (simulation d'autres systèmes,...)
      \item Audit
      \item Files d'attentes d'entrées/sorties
      \item Statistiques d'usage
      \item Priorité
      \item Gestion des machines parallèles \Anuma
      \item ...
      \end{itemizet}
    \item Chaque processus a une (petite) pile dans le noyau
    \item Chaque processus utilisateur a aussi une pile dans espace
      mémoire utilisateur
    \item Reliés par une double liste chaînée
    \item Tout n'est pas nécessaire pour faire des changement de tâches
      \begin{itemizet}
      \item Hiérarchisation
      \item Le minimum vital est en haut de la pile noyau du processus
      \item Rapide (cache) et facile (déplacement pointeur de pile) à
        accéder
      \end{itemizet}
\LinuxDecl{thread\_info}{include/linux/thread\_info.h}
\begin{lstlisting}
struct thread_info {
  struct task_struct	*task;		/* main task structure */
  struct exec_domain	*exec_domain;	/* execution domain */
  unsigned long		flags;		/* low level flags */
  unsigned long		status;		/* thread-synchronous flags */
  __u32			cpu;		/* current CPU */
  __s32			preempt_count; /* 0 => preemptable, <0 => BUG */
  mm_segment_t		addr_limit;	/* thread address space	*/
  struct restart_block    restart_block;
  unsigned long           previous_esp;   /* ESP of the previous stack in case
						   of nested (IRQ) stacks
  __u8			supervisor_stack[0];
};
\end{lstlisting}
  \end{itemizer}
\end{trans}


\begin{trans}{Accès aux tâches}
  \begin{itemizer}
  \item \lstinline/current_thread_info()/ pointe vers le descripteur
    courant
\begin{lstlisting}
static inline struct thread_info *current_thread_info(void)
{
  struct thread_info *ti;
  __asm__("andl %%esp,%0; ":"=r" (ti) : "" (~(THREAD_SIZE - 1)));
  return ti;
}      
\end{lstlisting}
\item \lstinline/current()/ pointe vers le descripteur
    courant de la \lstinline/task_info/ complète
  \item Adresse pas pratique pour un utilisateur (si processus migre,...)
     \vavers notion de \emph{pid} sur 16 ou 32~bits dans \lstinline/task_info/
     \begin{itemizet}
     \item Limite dans \verb|/proc/sys/kernel/pid_max| changeable pour
       gros serveurs 64~bits...
     \item Allocation de \emph{pid} par un bitmap
     \item Fonction de hachage pour retrouver rapidement une tâche à
       partir de son \emph{pid}
     \end{itemizet}
   \item \LinuxFile{kernel/pid.c}
  \end{itemizer}
  
\end{trans}


\begin{trans}{Graphe des états d'un processus}
  \psfiglarge{systemes_exploitation/graphe-etats-processus.idraw}
\end{trans}


\begin{trans}{Un processus Unix dans tous ses états}
  \psfiglarge{systemes_exploitation/graphe-etats-processus-unix.idraw}
\end{trans}


\begin{trans}{États internes dans Linux}
  Dans descripteur processus
  \LinuxDecl{task\_struct}{include/linux/sched.h} : champ \texttt{task}    
  \begin{itemizet}
  \item \verb/#define TASK_RUNNING 0/ : le processus est en train de
    fonctionner ou est sur une file d'attente pour. Si processus en mode
    utilisateur forcément en train de... s'exécuter \smiley\\
    \texttt{R} dans \texttt{ps}/\texttt{top}
  \item Le processus est bloqué en attente (endormi) d'un événement ou
    entrée-sortie pour repasser dans l'état \verb/TASK_RUNNING/
    \begin{itemizer}
    \item \verb/#define TASK_INTERRUPTIBLE 1/ : le processus peut être
      réveillé aussi par un signal\\
      \texttt{S} dans \texttt{ps}/\texttt{top}
    \item \verb/#define TASK_UNINTERRUPTIBLE 2/ : idem mais ne peut pas
      être réveillé par un signal. Utile si processus veut dormir sans
      interruption, si événement attendu rapidement et réserve de
      ressources importantes,...\\
      \texttt{D} dans \texttt{ps}/\texttt{top}\\
      \Attention Un signal \texttt{SIGKILL} ne peut même pas en venir à
      bout... Mais peut-être voulu si des ressources ont été bloquées et
      ne seraient pas libérées. Problème si bug néanmoins \frownie\\
      \vavers Éviter si possible
    \end{itemizer}
  \item \verb/#define TASK_STOPPED 4/ : est stoppé suite à
    \texttt{SIGTSTOP} (\verb/^Z/ du shell,...) \texttt{SIGSTOP} (ne peut
    pas être contré) ou suite à une entrée-sortie
    alors qu'il est en tâche de fond (\texttt{SIGTTIN} \&
    \texttt{SIGTTOU}). Continue si \texttt{SIGCONT}\\
    \texttt{T} dans \texttt{ps}/\texttt{top}
  \item \verb/#define TASK_TRACED 8/ : un processus est en train de tracer
    tout ce qu'il fait (\texttt{strace} pour lister appels systèmes,
    \texttt{gdb} pour débugguer,...)
  \item \verb/#define EXIT_ZOMBIE 16/ : le processus n'existe plus. État
    juste pour retourner \verb/task_struct.exit_code/ au processus parent
    quand il fera un \texttt{wait()}
    \begin{itemizer}
    \item Si pas de parent, \texttt{init} joue le rôle de parrain et fait
      un \texttt{wait()} de complaisance
    \item Si parent mal écrit et ne fait jamais de \texttt{wait()},
      développement des zombies... \frownie
    \end{itemizer}
  \item \verb/#define EXIT_DEAD 32/ : paix à son âme
  \end{itemizet}
\end{trans}


%\begin{trans}{Itérer sur des processus}
%  \begin{itemizer}
%  \item Les processus sont dans une liste chaînée
%
%  \end{itemizer}
%\end{trans}

\subsection{Entrées-sorties}


\begin{trans}{Entrées-sorties physiques (bas niveau)}
  \psfigtaille{systemes_exploitation/ES-physiques.idraw}{0.8\hsize}
\end{trans}


\begin{trans}{Déroulement d'une entrée-sortie physique}
  \begin{enumerate}
  \item Processus 1 s'exécute (actif)
  \item Exécution d'une fonction de demande d'entrée-sortie
  \item Appel au noyau via interruption logicielle
    \begin{enumerate}
    \item Préparation de l'entrée-sortie
    \item Lancement de l'entrée-sortie
    \item Ordonnanceur
    \end{enumerate}
  \item \vavers{} Processus 1 bloqué (dans et hors noyau)
  \item Interruption matérielle de fin d'entrée-sortie
    \begin{enumerate}
    \item Traitement de fin d'entrée-sortie
    \item Ordonnanceur
    \end{enumerate}
  \item Processus 1 activable
  \end{enumerate}
\end{trans}


\subsection{Gestion du temps qui passe}


\begin{trans}{Temps}
  \begin{itemizer}
  \item Attribution des ressources à tour de rôle
  \item \vavers{} Temps : crucial dans un système d'exploitation
  \item Périphérique particulier qui donne le temps : l'horloge
  \item Besoin
    \begin{itemizet}
    \item Connaître l'heure
    \item Faire des choses à intervalles régulier 
    \end{itemizet}
  \item Part d'une fréquence régulière de base qu'on divise d'un bon
    facteur
  \item Base selon richesse et précision :
    \begin{itemizet}
    \item Oscillateur RC
    \item Filtre céramique
    \item Courant secteur 50 Hz
    \item Résonnateur à quartz (éventuellement thermostaté)
    \item Stations radios (GPS, France Inter ou BBC en GO,...)
    \item Horloge atomique : utilise des fréquences de transition entre 2
      états atomiques\\
      \LienPDF{http://www.obs-besancon.fr/www/tf/equipes/vernotte/echelles/echelles_de_temps.html}\\
      \LienPDF{http://www.chez.com/tempsatomique/nouvellepage3.htm}
      \begin{itemizec}
      \item Nouvelle définition du temps : « \emph{La seconde est la durée
          de 9\,192\,631\,770 périodes de la radiation correspondant à la
          transition entre les deux niveaux hyperfins de l'état
          fondamental de l'atome de Césium 133} »\\
        Idée : coupler un oscillateur sur la résonance d'atomes d'un jet
        de césium 133 (le plus lent possible\ldots)
      \item MASER à hydrogène : meilleur en stabilité à court terme
      \item Horloges à cellule de rubidium, au mercure,\ldots
      \end{itemizec}
      {\tiny Merci à Jean François \textsc{Dutrey} du Laboratoire de
        métrologie Temps-Fréquence pour ses précisions~!}
    \end{itemizet}
  \end{itemizer}
\end{trans}


\begin{trans}{Génération d'événements}
  \begin{itemizer}
  \item Mécanisme matériel avec 1 registre T et un compteur C
  \item À chaque coup d'horloge faire
\begin{verbatim}
C--
if (C == 0) {
   C = T
   Générer signal ou interruption
}
\end{verbatim}
  \item Exemple d'usage à chaque interruption
    \begin{itemizet}
    \item Gérer un temps macroscopique en incrémentant un autre compteur
      (\Attention{} si débordement du compteur...)
    \item Rendre activables ou stoppés certains processus
    \item Redonner la main à l'ordonnanceur qui choisit quel processus
      faire tourner
    \end{itemizet}
  \end{itemizer}
\end{trans}


\begin{trans}{L'heure et sa distribution}
  \begin{itemizer}
  \item Des horloges partout...
  \item ...Mais rarement à l'heure, ni synchronisées \frownie
  \item Problématique si systèmes de fichiers distribués et
    \texttt{Makefile} par exemple ou corrélation de phénomènes physiques
  \item Besoin de synchronisation globale : diffusion d'une référence par
    un moyen quelconque et recalage
    \begin{itemizec}
    \item Radiodiffusion
      \begin{itemizet}
      \item Radio Frankfurt 10 MHz
      \item Modulation porteuse France Inter GO
      \item RDS de la bande FM
      \item Satellite GPS
      \end{itemizet}
    \item Protocoles réseau\\
      NTP : Distribution du temps \& Mesure statistique du temps de
      transmission depuis un serveur de référence
    \end{itemizec}
  \end{itemizer}
\begin{exemple}
chailly99-keryell > ntpq -p
remote           refid      st t when poll reach   delay   offset    disp
=========================================================================
*orgenoy   canon.inria.fr   2 u   51   64  377     0.66    0.255     0.14
\end{exemple}
\end{trans}


\subsection{Ordonnancement}


\begin{trans}{Ordonnancement}
  \begin{itemizer}
  \item Système d'exploitation multitâche
    \begin{itemizet}
    \item Plein de processus veulent tourner
    \item Un ou plusieurs processeurs
    \item De nombreuses possibilités
    \item Lesquels faire tourner en premier ?
    \end{itemizet}
  \item 2 objectifs difficiles à atteindre
    \begin{itemizet}
    \item S'assurer d'un bon taux d'utilisation des processeurs
    \item S'assurer que chaque processus a le service qu'il souhaite
    \end{itemizet}
  \item Satisfaction des processus interactif au détriment des travaux par
    lots
  \item Coût des changements de contexte, des transferts de mémoire
    principale--mémoire secondaire,...
  \item Processus souvent connus qu'à l'exécution \frownie{} \vavers{}
    ordonnancement dynamique
  \end{itemizer}
\end{trans}


\begin{trans}{Priorité}
  Associer une priorité à chaque processus en fonction de
  \begin{itemizer}
  \item Objectifs globaux du système (système à temps partagé, traitement
    par lots, contrôle de procédés industriels,...)
  \item Caractéristiques de chaque processus (échéance temporelle,
    périodicité, temps processeur récemment consommé, temps récemment
    passé en sommeil,...)
  \item Caractéristiques de chaque périphérique : ne pas ralentir des
    périphériques qui sont déjà lents,...
  \end{itemizer}
\end{trans}


\begin{trans}{Types de multitâche}
  \begin{itemizet}
  \item Multitâche coopératif
    \begin{itemizer}
    \item Chaque processus a prévu de passer la main aux autres
    \item Nécessite une architecture logicielle précise
    \item Comportement assez prédictible
    \item Difficile de faire des choses complexes
    \end{itemizer}
  \item Multitâche préemptif
    \begin{itemizer}
    \item Même si une tâche n'a pas prévu de s'arrêter le système peut
      en faire tourner une autre à la place après un quantum de temps
    \item Globalement plus simple à mettre en place
    \item Pas de garantie facile à assurer sur les contraintes
    \end{itemizer}
  \end{itemizet}
  Systèmes d'exploitations modernes généralistes : font les deux (Linux
  2.6, Solaris,...)
\end{trans}


\begin{trans}{Quelques politiques d'ordonnancement}
  \begin{itemizer}
  \item Premier Arrivé Premier Servi (PAPS) ou \emph{First In First Out}
    (FIFO)
  \item Tourniquet (\emph{round robin}) ou partage du temps
  \item Priorité statique (temps réel) ou dynamique
  \item \emph{Shortest job first}... Mais nécessite de connaître la durée
    de la tâche (future)
  \item \emph{Earliest deadline first}... Mais nécessite de connaître la
    date de fin (future)
  \item \emph{Smaller period first} (\emph{Rate Monotonic scheduling})...
    Nécessite de préciser les intervalles de lancement
  \item ...
  \end{itemizer}
\end{trans}


\begin{trans}{Processus dirigé par le calcul ou les E/S}
  \belleboite{Programme $\equiv$ calculs + E/S}
  ... mais rarement équilibré. Souvent 2 aspects se dégagent :
  \begin{itemizer}
  \item Processus orienté calcul
    \begin{itemizet}
    \item Gros calculs
    \item Préemption fréquente gâcherait du temps (système, cache,
      swap,...)
    \item Réactivité moins évidente à l'utilisateur
    \end{itemizet}
  \item Processus orienté entrées-sorties
    \begin{itemizet}
    \item Calculs souvent bloqués par des E/S
    \item Préemption souvent évitée par blocage sur E/S
    \item Réactivité plus évidente à l'utilisateur (si c'est lui l'E/S !)
    \end{itemizet}
    D'un point de vue rentabilité processeur, intéressant d'avoir les 2 en
    même temps
  \end{itemizer}
\end{trans}


\begin{trans}{Temps partagé -- tourniquet}
  \deuxcolonnes{%
    \begin{itemizer}
    \item Donner illusion de disposer d'une machine à soi tout seul
    \item Lié à l'invention du terminal interactif
    \item Changer de programme à chaque quantum de temps
    \item Privilégier les requêtes peu gourmandes par rapport aux
      programmes de calcul : faire des heureux facilement avec
      \emph{caisse moins de 10 Articles}
    \end{itemizer}
    \psfiglarge{systemes_exploitation/tourniquet_p1.ps}
    }
\end{trans}


\begin{trans}{Blocage dans le tourniquet}
  \deuxcolonnes{%
    \begin{itemizer}
    \item Blocage possible d'un processeur avant la fin de son quantum de
      temps
    \item Libère du temps pour les autres
    \end{itemizer}
    \psfiglarge{systemes_exploitation/tourniquet_p2_court.ps}
    }
\end{trans}


\begin{trans}{Politique par priorité}
  Associer une priorité à chaque processus et faire fonctionner processus
  voulant tourner qui est le plus prioritaire

  Priorité choisie en fonction de
  \begin{itemizer}
  \item Objectifs globaux du système (système à temps partagé, traitement
    par lots, contrôle de procédés industriels,...)
  \item Caractéristiques de chaque processus (échéance temporelle,
    périodicité, temps processeur récemment consommé, temps récemment
    passé en sommeil,...) si on veut une politique a priorité plus
    dynamique
  \item Caractéristiques de chaque périphérique : ne pas ralentir des
    périphériques qui sont déjà lents,...
  \end{itemizer}
\end{trans}


\begin{trans}{Politique à priorités dans Unix}
  \begin{center}
  \begin{tabular}{|r|c|l}
    \cline{1-2}
    \emph{Priorité} ($p_{\text{base}}$) & \emph{Exemple} & \emph{Type} \\\cline{1-2}\cline{1-2}
    +19 (+ faible) & Useur d'écran & \\\cline{1-2}
    $\vdots$ & $\vdots$ & Plutôt utilisateur\\\cline{1-2}
    +1  & & \\\cline{1-2}
    0 (standard) & Jeux vidéo & \\\cline{1-2}
    -1  & Numérisation d'un cours & \\\cline{1-2}
    $\vdots$ & $\vdots$ & Plutôt système\\\cline{1-2}
    -20 (+ forte) & & \\\cline{1-2}
  \end{tabular}
\end{center}
\begin{itemizer}
  \item Processus « noyau » ont une priorité (négative en Unix...) forte
  \item Processus utilisateurs ont une priorité (positive en Unix...)
    faible
  \item Un utilisateur peut seulement baisser la priorité d'un processus
    utilisateur \smiley (modifie sa base) à l'aide de la commande
    \texttt{nice}
  \item Le super utilisateur peut augmenter la priorité
  \item Ordonnancement :
    \begin{itemizet}
    \item Faire tourner les processus de plus forte priorité entre eux en
      tourniquet
    \item Un processus utilisateur qui a dépassé son quantum de temps est
      remis en queue de sa file d'attente (tourniquet)
    \item Toutes les secondes, on recalcule les priorités sur le thème
      \[
      p_{\text{base}} + \text{temps}_{\text{utilisation processeur}}
      \]
      Avec $p_{\text{base}}$ donné par la commande \texttt{nice} (0 par
      défaut)
    \end{itemizet}
  \item Rajout aussi d'ordonnanceur « temps réel » en plus dans les Unix
    modernes : permet d'avoir aussi des processus qui tournent avec des
    contraintes fortes
  \end{itemizer}
\end{trans}


\begin{trans}{Toutes les priorités dans Linux}
  \LinuxFile{include/linux/sched.h}
\begin{lstlisting}
/*
 * Priority of a process goes from 0..MAX_PRIO-1, valid RT
 * priority is 0..MAX_RT_PRIO-1, and SCHED_NORMAL tasks are
 * in the range MAX_RT_PRIO..MAX_PRIO-1. Priority values
 * are inverted: lower p->prio value means higher priority.
 *
 * The MAX_USER_RT_PRIO value allows the actual maximum
 * RT priority to be separate from the value exported to
 * user-space.  This allows kernel threads to set their
 * priority to a value higher than any user task. Note:
 * MAX_RT_PRIO must not be smaller than MAX_USER_RT_PRIO.
 */
#define MAX_USER_RT_PRIO	100
#define MAX_RT_PRIO		MAX_USER_RT_PRIO

#define MAX_PRIO		(MAX_RT_PRIO + 40)
\end{lstlisting}
  \LinuxFile{kernel/sched.c}
\begin{lstlisting}
/*
 * Convert user-nice values [ -20 ... 0 ... 19 ]
 * to static priority [ MAX_RT_PRIO..MAX_PRIO-1 ],
 * and back.
 */
#define NICE_TO_PRIO(nice)	(MAX_RT_PRIO + (nice) + 20)
#define PRIO_TO_NICE(prio)	((prio) - MAX_RT_PRIO - 20)
#define TASK_NICE(p)		PRIO_TO_NICE((p)->static_prio)

/*
 * 'User priority' is the nice value converted to something we
 * can work with better when scaling various scheduler parameters,
 * it's a [ 0 ... 39 ] range.
 */
#define USER_PRIO(p)		((p)-MAX_RT_PRIO)
#define TASK_USER_PRIO(p)	USER_PRIO((p)->static_prio)
#define MAX_USER_PRIO		(USER_PRIO(MAX_PRIO))
\end{lstlisting}
\end{trans}

\begin{trans}{Exemple de processus Unix avec top}
  \texttt{top} permet de visualiser les processus de manière interactive
\begin{exemple}
Tasks: 134 total,   5 running, 129 sleeping,   0 stopped,   0 zombie
Cpu(s):  97.4% user,   2.6% system,   0.0% nice,   0.0% idle
Mem:    514572k total,   505464k used,     9108k free,    41872k buffers
Swap:  2048248k total,    57620k used,  1990628k free,   150544k cached

  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
26487 even      16   0  185m 185m  784 R 95.7 36.8 158:20.05 prose
15440 keryell    9   0  2800 1944 1704 R  3.3  0.4   8:23.54 sshd
26540 keryell   11   0  1000 1000  768 R  0.7  0.2   0:00.60 top
17441 keryell    9   0 31244  28m  27m S  0.3  5.6  12:18.96 mozilla-bin
    1 root       9   0   436  412  388 S  0.0  0.1   1:26.93 init
    2 root       9   0     0    0    0 S  0.0  0.0   0:00.14 keventd
    3 root       9   0     0    0    0 S  0.0  0.0   0:36.84 kapmd
    4 root      19  19     0    0    0 S  0.0  0.0   1:37.74 ksoftirqd_CPU0
    5 root       9   0     0    0    0 S  0.0  0.0  59:20.41 kswapd
    6 root       9   0     0    0    0 S  0.0  0.0   0:00.00 bdflush
    7 root       9   0     0    0    0 S  0.0  0.0   1:29.13 kupdated
  381 root       5 -10 90400 1480 1408 S  0.0  0.3  33:38.10 XFree86
\end{exemple}
Autres commandes : \texttt{ps -ef} (Système V), \texttt{ps augxww} (BSD),\ldots
\end{trans}


\begin{trans}{Choix du quantum de temps dans Linux}
  \begin{itemizer}
  \item Un quantum (\emph{time slice}) identique pour tout le monde n'est
    pas la solution optimale
    \begin{itemizet}
    \item Trop long : peu interactif pour les autres
    \item Trop court : trop de temps perdu en changements de contextes
    \end{itemizet}
  \item Clair qu'idéalement un petit quantum est préférable \vavers
    souvent autour de 50~ms dans les Unix
  \item Mais tâche plus prioritaire tournera plus souvent même si petit
    quantum
  \item Idée : allouer un quantum variable en fonction de la priorité ou
    interactivité et faire un tourniquet sur tous ces processus jusqu'à
    épuisement des quanta
    \begin{itemizet}
    \item Quantum par défaut : 100 ms
    \item Processus plus interactif ou plus prioritaire : tend vers 800~ms
    \item Processus moins interactif ou prioritaire : tend vers 5~ms
    \item Un quantum peut être consommé en plusieurs changement de
      contexte dans un tour de tourniquet (50 passage de 1~ms pour un
      processus très interactif par exemple)
    \item Recalcul des quanta après chaque tour
    \end{itemizet}
  \item Préemption lorsque
    \begin{itemizet}
    \item Un processus passe dans l'état \texttt{RUNNING} et que sa
      priorité est supérieure à celle du processus en cours d'exécution :
      changement de processus
    \item Un processus a terminé son quantum de temps
    \end{itemizet}
  \end{itemizer}  
\end{trans}


\begin{trans}{Ordonnanceur Linux 2.6}
  \begin{itemizer}
  \item Bonne interactivité même si forte charge
  \item Essaye de respecter une certaine équité : pas de misère
  \item Optimise le cas courant de quelques processus actifs mais tient la
    charge
  \item Algorithme d'ordonnancement indépendant du nombre de processeurs :
    $\mathcal{O}(1)$
  \item Chaque processeur a sa liste de processus : bonne montée en charge
    parallèle (extensibilité) car pas de conflit
  \item Exploite la localité des processus sur processeurs (affinité) :
    meilleure utilisation des caches,...
  \item Tâche de migration de processus vers des processeurs moins chargés
  \item Gère le rajout et la disparition des processeurs
  \end{itemizer}
\end{trans}


\begin{trans}{File d'exécution (\protect\emph{runqueues})}
  \begin{itemizer}
  \item Tous les processus actifs/activables sont rangés dans une
    file d'exécution (\emph{runqueue})/processeur
  \item Un extrait de \LinuxDecl{runqueue}{kernel/sched.c} :
\begin{lstlisting}
struct runqueue {
  spinlock_t lock;
  unsigned long nr_running;
#ifdef CONFIG_SMP
  unsigned long cpu_load;
#endif
  unsigned long long nr_switches;
  unsigned long nr_uninterruptible;

  unsigned long expired_timestamp; /* Date de l'échange d'arrays */
  unsigned long long timestamp_last_tick;
  task_t *curr, *idle;
  struct mm_struct *prev_mm; /* Espace mémoire de la tâche précédente */
  prio_array_t *active, *expired, arrays[2];
  int best_expired_prio;
  atomic_t nr_iowait;
 ...
 /* Des choses pour le multiprocesseur et des statistiques */
}
\end{lstlisting}
  \end{itemizer}
\end{trans}


\begin{trans}{Tableaux de priorité}
  \begin{itemizer}
  \item Sur chaque file d'exécution (\emph{runqueue}) avec $n$ processus
    il faut
    \begin{itemizet}
    \item Trouver tâche plus prioritaire
    \item Exécuter tâche plus prioritaire
    \item La mettre après exécution si quantum expiré dans une liste des
      tâches ayant consommé leur quantum de temps
    \end{itemizet}
    \vavers Besoin d'une bonne structure de données pour éviter d'aller à
    la pêche en $\mathcal{O}(n)$ comme dans Linux 2.4...
  \item Idée : s'inspirer du \emph{bucket sort} des facteurs de la poste
    \begin{itemizet}
    \item Mettre autant de files qu'il y a de niveaux de priorité
    \item Mettre chaque tâche dans la file correspondante
    \item Exécuter tâche de la file non vide de plus forte priorité
    \end{itemizet}
    \vavers Recherche en $\mathcal{O}(\mathrm{\#prio})$
  \item Certains processeurs ont des instructions pour trouver position
    premier bit à 1 dans une chaîne (\texttt{ffs},...) en
    $\mathcal{O}(\log\mathrm{bitsizeof(int)})$, en général 1 cycle
    \begin{itemizet}
    \item Construire 1 tableau de bits associé aux files avec bit à 1 si
      file non vide
    \item Trouver en
      $\mathcal{O}(\frac{\mathrm{\#prio}}{\mathrm{bitsizeof(int)}}\log\mathrm{bitsizeof(int)})$
      la position de la première file non vide
    \item Si 140 niveaux de priorité et mots de 32 bits, au plus 5
      \texttt{ffs} pour parcourir le champ de 160~bits dans
      \verb|sched_find_first_bit()|
    \end{itemizet}
  \item Comme cela ne dépend plus de $n$, on parle d'ordonnanceur à temps
    constant en $\mathcal{O}(1)$
  \end{itemizer}
\begin{lstlisting}
#define BITMAP_SIZE ((((MAX_PRIO+1+7)/8)+sizeof(long)-1)/sizeof(long))
struct prio_array {
	unsigned int nr_active;
	unsigned long bitmap[BITMAP_SIZE];
	struct list_head queue[MAX_PRIO];
};
\end{lstlisting}
\end{trans}


\begin{trans}{Recalculer les quanta de temps}
  \begin{itemizer}
  \item Idée de base
    \begin{itemizet}
    \item Itérer sur toutes les tâches
    \item Si une tâche a usé son quantum de temps, le recalculer (en
      fonction de plein de paramètres : priorité, interactivité,
      histoire,...)
    \item \Attention Grosse boucle $\mathcal{O}(n)$ avec des mécanismes
      d'exclusion mutuelle partout assez incompatible avec du temps
      réel... \frownie
    \end{itemizet}
  \item Version Linux 2.6
\begin{lstlisting}
struct runqueue {
 ...
  prio_array_t *active, *expired, arrays[2];
 ...
}
\end{lstlisting}
    \begin{itemizet}
    \item On alloue un nouveau tableau de priorité \texttt{expired} pour
      les tâches ayant usé leur temps
    \item Dès qu'une tâche de \texttt{active} a usé son quantum, on
      recalcule son quantum et on la met au bon endroit dans le tableau
      \texttt{expired}
    \item Lorsque le tableau de priorité \texttt{active} est vide on
      échange les 2 tableaux et on recommence
    \item Fait dans \LinuxFuncDecl{schedule}{kernel/sched.c}
\begin{lstlisting}
array = rq->active;
if (unlikely(!array->nr_active)) {
	/*
	 * Switch the active and expired arrays.
	 */
	schedstat_inc(rq, sched_switch);
	rq->active = rq->expired;
	rq->expired = array;
	array = rq->active;
	rq->expired_timestamp = 0;
	rq->best_expired_prio = MAX_PRIO;
} else
	schedstat_inc(rq, sched_noswitch);
\end{lstlisting}
    \item Devient donc un petit $\mathcal{O}(n)$ moins violent que dans le
      2.4
    \end{itemizet}
  \end{itemizer}
\end{trans}


\begin{trans}{La fonction d'ordonnancement schedule()}
  \begin{itemizer}
  \item Appelée
    \begin{itemizet}
    \item Explicitement par une tâche noyau altruiste
    \item À la fin d'un quantum de temps d'un processus
    \item Après chaque changement de priorité ou d'état
    \end{itemizet}
  \item \LinuxFuncDecl{schedule}{kernel/sched.c}
\begin{lstlisting}
idx = sched_find_first_bit(array->bitmap);
queue = array->queue + idx;
next = list_entry(queue->next, task_t, run_list);
\end{lstlisting}
  \end{itemizer}
\end{trans}


\begin{trans}{Calcul des priorités dynamiques et quanta}
  \begin{itemizer}
  \item Un processus utilisateur a par défaut un priorité de sympathie
    envers les autres ($\mathit{nice}\in[-20,19]$) : \texttt{static\_prio}
  \item \LinuxFuncDecl{effective\_prio}{kernel/sched.c} calcule la priorité
    dynamique \texttt{prio}
\begin{lstlisting}
/*
 * effective_prio - return the priority that is based on the static
 * priority but is modified by bonuses/penalties.
 *
 * We scale the actual sleep average [0 .... MAX_SLEEP_AVG]
 * into the -5 ... 0 ... +5 bonus/penalty range.
 *
 * We use 25% of the full 0...39 priority range so that:
 *
 * 1) nice +19 interactive tasks do not preempt nice 0 CPU hogs.
 * 2) nice -20 CPU hogs do not get preempted by nice 0 tasks.
 *
 * Both properties are important to certain workloads.
 */
#define CURRENT_BONUS(p) \
	(NS_TO_JIFFIES((p)->sleep_avg) * MAX_BONUS / \
		MAX_SLEEP_AVG)
static int effective_prio(task_t *p)
{
	int bonus, prio;

	if (rt_task(p))
		return p->prio;

	bonus = CURRENT_BONUS(p) - MAX_BONUS / 2;

	prio = p->static_prio - bonus;
	if (prio < MAX_RT_PRIO)
		prio = MAX_RT_PRIO;
	if (prio > MAX_PRIO-1)
		prio = MAX_PRIO-1;
	return prio;
}
\end{lstlisting}
\item En gros si une tâche dort beaucoup elle est interactive et donc elle
  gagne un bonus de priorité
\item Un nouveau processus part avec un grand \verb|sleep_avg| pour bien
  démarrer dans la vie
\item 
\begin{lstlisting}
/*
 * task_timeslice() scales user-nice values [ -20 ... 0 ... 19 ]
 * to time slice values: [800ms ... 100ms ... 5ms]
 *
 * The higher a thread's priority, the bigger timeslices
 * it gets during one round of execution. But even the lowest
 * priority thread gets MIN_TIMESLICE worth of execution time.
 */
#define MIN_TIMESLICE		max(5 * HZ / 1000, 1)
#define DEF_TIMESLICE		(100 * HZ / 1000)
#define SCALE_PRIO(x, prio) \
	max(x * (MAX_PRIO - prio) / (MAX_USER_PRIO/2), MIN_TIMESLICE)

static unsigned int task_timeslice(task_t *p)
{
	if (p->static_prio < NICE_TO_PRIO(0))
		return SCALE_PRIO(DEF_TIMESLICE*4, p->static_prio);
	else
		return SCALE_PRIO(DEF_TIMESLICE, p->static_prio);
}
\end{lstlisting}
  \end{itemizer}
\end{trans}


\begin{trans}{Sommeil \& réveil}
  \begin{itemize}
  \item Les tâches ont aussi besoin de se reposer
  \item Évite les attentes actives inutiles
  \item Permet de faire du travail utile pendant ce temps
  \item Gestion des états \verb/TASK_INTERRUPTIBLE/ et
    \verb/TASK_UNINTERRUPTIBLE/
  \item Introduction de files d'attentes (\emph{wait queue}) pour
    collectionner processus à réveiller sur un événement particulier
  \item Le réveil des tâches en attente est fait par
    \LinuxFuncDecl{\_\_wake\_up}{kernel/sched.c}
  \end{itemize}
  Exemple de \LinuxFuncDecl{do\_clock\_nanosleep}{kernel/posix-timers.c}
\begin{lstlisting}
long
do_clock_nanosleep(clockid_t which_clock, int flags, struct timespec *tsave)
{
  ...
  /* Crée un élément de liste abs_wqueue avec la tâche courante comme
     valeur, style abs_wqueue = CONS(current, NIL) */
  DECLARE_WAITQUEUE(abs_wqueue, current);
  ...
  init_timer(&new_timer);
  new_timer.expires = 0;
  new_timer.data = (unsigned long) current;
  new_timer.function = nanosleep_wake_up;
  abs = flags & TIMER_ABSTIME;
  ...
  if (abs && (posix_clocks[which_clock].clock_get !=
                      posix_clocks[CLOCK_MONOTONIC].clock_get))
          /* En gros fait
          nanosleep_abs_wqueue = CONS(current, nanosleep_abs_wqueue) */
          add_wait_queue(&nanosleep_abs_wqueue, &abs_wqueue);

  new_timer.expires = jiffies + left;
  __set_current_state(TASK_INTERRUPTIBLE);
  add_timer(&new_timer);

  schedule();
  ...
  return 0;
}
\end{lstlisting}
\end{trans}


\begin{trans}{Préemption}
  \begin{itemizer}
  \item Effectué par \LinuxFuncDecl{schedule}{kernel/sched.c} qui appelle
    \LinuxFuncDecl{context\_switch}{kernel/sched.c}
  \item Peut arriver
    \begin{itemizet}
    \item Processus utilisateur : au moment de revenir dans
      l'espace utilisateur depuis un appel système ou une interruption
    \item Tâche noyau : après un retour d'interruption, sur blocage, appel
      explicite à \texttt{schedule()} ou lorsque le noyau redevient préemptif
    \end{itemizet}
  \item Une tâche dans le noyau est préemptible si elle ne possède aucun
    verrou de posé (comptabilisés par le champ \texttt{preempt\_count} de
    la \texttt{thread\_info})
  \item La préemption est globalement contrôlée par le drapeau
    \verb|need_resched| qui est positionné si quelqu'un a besoin d'avoir
    la main
  \end{itemizer}
\end{trans}


\begin{trans}{Équilibrage de charge}
  \begin{itemizer}
  \item Multiprocesseur capable d'exécuter plusieurs processus en parallèle
  \item Pour des raisons d'efficacité, tâches associées à un processus
  \item Il se peut que des processeurs soient beaucoup plus chargés que
    d'autres... \frownie
  \item \LinuxFuncDecl{schedule}{kernel/sched.c} appelle régulièrement
    \LinuxFuncDecl{load\_balance}{kernel/sched.c}
    \begin{itemizet}
    \item Si pas de déséquilibre de plus de 25\,\% ne fait rien
    \item Sinon prend une tâche de haute priorité (à équilibre
      principalement) qui n'a pas tourné
      depuis longtemps (cache...) et essaye de la bouger
    \end{itemizet}
  \end{itemizer}
\end{trans}


\begin{trans}{Affinité tâche-processeur}
  \begin{itemizer}
  \item Une tâche tourne sur \emph{un} processeur  \item Est-ce indépendant de la localisation ?
    \begin{itemizet}
    \item Fonctionnellement oui...
    \item ... \Attention performances !
    \end{itemizet}
  \item Architecture sous-jacente complexe
    \begin{itemizet}
    \item Mémoires caches dans les processeurs
    \item Architectures \Anuma (\emph{Non Uniform Memory Access})
    \item Architectures hétérogènes : cartes réseaux et processeurs
      \begin{itemizec}
      \item Faire tourner un processus qui traite des paquets d'une
        interface réseau sur un processeur proche de celle-ci
      \end{itemizec}
    \end{itemizet}
  \end{itemizer}
  \belleboite{\vavers Besoin de contrôler finement la localisation} Cf.
  \texttt{man} de \verb|taskset(1)|, \verb|sched_setaffinity(2)|,
  \verb|sched_getaffinity(2)|
\end{trans}


\begin{trans}{Unix : 2 ordonnancement}
  Interaction avec mémoire virtuelle et mémoire secondaire car 1
  processeur ne peut exécuter que des instructions en mémoire principale
  \begin{itemizer}
  \item Au niveau bas : ordonnanceur choisit de rentre actif 1 processus
    activable \emph{présent en mémoire principale}
  \item Au niveau haut : ordonnanceur gère le va-et-vient (\emph{swap})
    entre la mémoire principale et la mémoire secondaire. Modifie les
    priorités pour favoriser processus qui viennent de rentrer en mémoire
    principale, etc.
  \end{itemizer}
  Choix averti de l'ordonnanceur \vavers{} noyau a constamment en mémoire
  principale une table de l'ensemble des processus avec données nécessaire
  au fonctionnement de l'ordonnanceur
\end{trans}


\begin{trans}{Ordonnancement et va et vient}
  \begin{itemizer}
  \item Certaines informations liées à un processus restent en mémoire
    principale
    \begin{itemizet}
    \item Paramètres d'ordonnancement
    \item Adresses sur disques des segments/pages du processus
    \item Informations sur les signaux UNIX acceptés
    \item ...
    \end{itemizet}
  \item D'autres informations suivent le processus quand il est mis
    (\emph{swap out}) en mémoire secondaire
    \begin{itemizet}
    \item Contexte matériel
    \item Table de descripteurs de fichiers
    \item Pile du noyau (stockage des variables locales du noyau lorsqu'il
      traite le processus) et la pile « utilisateur » (stockage des
      variables locales lors des calculs)
    \end{itemizet}
  \end{itemizer}
\end{trans}


\begin{trans}{Politiques temps réel}
  En plus de la politique non temps réel \verb/SCHED_NORMAL/ il y a 2
  politiques plus temps réel dans Linux 2.6
  \begin{itemizer}
  \item \verb/SCHED_FIFO/
    \begin{itemizet}
    \item Une telle tâche passera toujours avant une \verb/SCHED_NORMAL/
    \item Préemption
    \item Tourne tant qu'elle n'est pas bloquée ou fait un
      \verb/sched_yield()/ ou une tâche temps réel plus prioritaire veut tourner    \end{itemizet}
  \item \verb/SCHED_RR/
    \begin{itemizet}
    \item Comme \verb/SCHED_FIFO/ mais avec des quanta de temps
    \item Tourniquet entre processus de même priorité
    \end{itemizet}
    Pas de garantie dure mais permet de faire plus de chose que
    \verb/SCHED_NORMAL/ classique de base

    Cf. \texttt{man} \texttt{chrt(1)}, \texttt{sched\_setscheduler(2)}
  \end{itemizer}
\end{trans}

\begin{trans}{Petite conclusion sur ordonnancement Linux}
  \begin{itemizer}
  \item De gros progrès dans Linux 2.6 !
  \item Noyau préemptif
  \item Rajout de priorités fixes temps réel
  \item Ordonnanceur efficace et rapide : regarder
    \LienPDF{http://developer.osdl.org/craiger/hackbench/index.html}
  \item Nouvelles politiques d'ordonnancement temps réel en plus de Unix
    dynamique classique
  \item Parti du monde du \Apc Linux aborde sans complexe toute l'étendue
    informatique : des systèmes embarqués aux super-calculateurs
    parallèles \Anuma
  \item Monde du logiciel libre
    \begin{itemizet}
    \item Pas captif d'un produit fermé
    \item On a les sources pour regarder dedans et adapter !
    \item Plein de documentation et d'exemples disponibles
    \item Grande communauté (support gratuit ou payant)
    \end{itemizet}
  \end{itemizer}
\end{trans}



\begin{trans}{Des ennuis : inversion de priorité}
  Supposons
  \begin{itemizer}
  \item 3 processus $P_1$, $P_2$ et $P_3$
  \item Un système à priorités fixes dures
  \item Priorités $p(P_1) > p(P_2) > p(P_3)$
  \end{itemizer}

  \newslide

  Cas pathologique :
  \psfiglarge{systemes_exploitation/inversion_priorite.idraw}
 
  \begin{itemizer}
  \item $P_1$ attend un message de $P_3$
  \item $P_2$ fonctionne à la place de $P_3$ car plus prioritaire
  \item Paradoxe : $P_2$ fonctionne à la place de $P_1$ et est donc plus
    prioritaire !
  \end{itemizer}
\end{trans}


\begin{trans}{Solutions possibles}
  Solutions possibles :
  \begin{itemizer}
  \item Héritage de priorité : faire hériter (provisoirement !) $P_3$ de
    la priorité de $P_1$
  \item \emph{Priority Ceiling Algorithms} : associer à une ressource une
    priorité qui sera prêtée aux tâches qui utilisent ou attendent cette
    ressource
  \end{itemizer}
\end{trans}


\begin{frame}[fragile]{Mars Pathfinder Mission on July 4th, 1997}
  \LienPDF{http://www.research.microsoft.com/\~mbj/Mars\_Pathfinder}
    
    The Mars Pathfinder mission was widely proclaimed as "flawless" in the
    early days after its July 4th, 1997 landing on the Martian surface.
    Successes included its unconventional "landing"-bouncing onto the
    Martian surface surrounded by airbags, deploying the Sojourner rover,
    and gathering and transmitting voluminous data back to Earth,
    including the panoramic pictures that were such a hit on the Web.
    
\end{frame}


\begin{trans}{Tâche martienne de priorité forte}
  A bus management task ran frequently with high priority to move certain
  kinds of data in and out of the information bus (1553 bus). Access to
  the bus was synchronized with mutual exclusion locks (mutexes).
\end{trans}


\begin{trans}{Tâche martienne de priorité faible}
  The meteorological data gathering task (ASI/MET) ran as an infrequent,
  low priority thread, and used the information bus to publish its data.
  When publishing its data, it would acquire a mutex, do writes to the
  bus, and release the mutex. If an interrupt caused the information bus
  thread to be scheduled while this mutex was held, and if the information
  bus thread then attempted to acquire this same mutex in order to
  retrieve published data, this would cause it to block on the mutex,
  waiting until the meteorological thread released the mutex before it
  could continue.
\end{trans}


\begin{trans}{Tâche martienne de priorité moyenne}
  The spacecraft also contained a bus communications task that
  ran with medium priority.
\end{trans}


\begin{trans}{Bug martien}
  Most of the time this combination worked fine. However, very
  infrequently, it was possible for an interrupt to occur that caused the
  (medium priority) communications task to be scheduled during the short
  interval while the (high priority) information bus thread was blocked
  waiting for the (low priority) meteorological data thread. In this case,
  the long-running communications task, having higher priority than the
  meteorological task, would prevent it from running, consequently
  preventing the blocked information bus task from running. After some
  time had passed, a watchdog timer would go off, notice that the data bus
  task had not been executed for some time, conclude that something had
  gone drastically wrong, and initiate a total system reset.
\end{trans}


\begin{trans}{Debug martien}
  \begin{itemizer}
  \item Vitesse de la lumière Terre-Mars $\approx$ 14 mn \frownie
  \item Récupérer une version du système temps réel (vxWorks) spécialement
    instrumentée pour le debug avec collecte de trace d'exécutions
  \item Faire tourner avec les mêmes tâches que sur Mars une maquette
    identique
  \item Bug apparu au bout de 18 heures
  \item Analyse : sémaphore utilisé sans option d'héritage de priorité
    (non mis par défaut pour des raisons d'optimisation)
  \item Besoin de modifier le code sur... Mars !
  \item Conception d'une rustine logicielle (\emph{patch})
  \item Mise en place avec une procédure spéciale... qui avait été prévue !
  \end{itemizer}
  \psfighautcentre{images/Mars_MacDonald.eps}
\end{trans}


\section{Gestion mémoire}


\begin{trans}{Gestion des mémoires}
  \begin{itemizer}
  \item Plusieurs types de mémoire
    \begin{itemizet}
    \item Grosses mémoires : pas chères
      \begin{itemizec}
      \item Magnétiques : disques durs, bandes, (disquettes),...
      \item Optiques : DVD, (CDROM),...
      \end{itemizec}
      Problème : lentes ! \frownie
    \item Mémoires rapides :
      \begin{itemizec}
      \item FLASH-ROM : moyennement rapide
      \item DRAM : rapide
      \item SRAM : très rapide
      \end{itemizec}
      Problème : faible capacité, très chères \frownie
    \end{itemizet}
  \item À moins d'être très riche (cf vieux supercalculateur Cray,...)
    besoin d'un compromis !
  \item Idée : garder le plus près possible de l'utilisation les données
    dans la mémoire la plus rapide
  \end{itemizer}
\end{trans}


\begin{trans}{Hiérarchie mémoire}
  \psfiglarge{systemes_exploitation/hierarchie_memoire.idraw}
\end{trans}


\begin{trans}{Hiérarchie mémoire version réseau}
  \psfiglarge{systemes_exploitation/hierarchie_memoire_reseau.idraw}
\end{trans}


\begin{trans}{Dépasser des limitations d'adressage}
  \begin{itemizer}
  \item Réduction du coût du matériel dans applications grand public (lave
    linge,...) : microcontrôleur 1-4-8 bits
  \item Mémoire adressable $<$ mémoire physique
  \item Comment accéder à des grosses mémoires lorsqu'on ne peut manipuler
    que des données sur 8 voire 16 bits (65536 valeurs d'adresses) ?
  \item Utilisation d'une fonction de translation $a_p = f(a_v)$ donnant
    l'adresse physique à partir d'une adresse virtuelle
  \item Cas des vieux PC avec i8088 : utilisation d'un registre de
    segment$s$ pour accéder à 1~Mo avec des registres d'adresse sur
    16~bits :
    \[
    a_p = a_v + 16× s
    \]
    Permet simplement d'avoir plusieurs programme simultanément chargés en
    mémoire (multiprogrammation) : pour changer la zone du programme
    exécuté changer $s$
  \item Cas du Goupil 3 avec 6809 : pagination avec accès possible à 16
    pages de 4~Ko parmi 256 pages (1~Mo) sélectionnable avec l'aide du
    système d'exploitation
    \psfiglarge{systemes_exploitation/adressage_Goupil3.idraw}
  \end{itemizer}
\end{trans}


\begin{trans}{Dépasser la mémoire physique}
  \begin{itemizer}
  \item Cas avec processeurs courants 32 ou 64 bits : mémoire physique
    (1~Go) $<$ mémoire adressable (16~Eo)
  \item Simuler la mémoire manquante avec de la mémoire \emph{moins chère}
    : mémoire secondaire (sur disque dur)
  \item Utilise grand espace disponible pour se simplifier la vie : on
    peut espacer les objets sans (trop) compter\\
    Par exemple si besoins de piles de taille inconnue pour des processus
    légers $p$ sur une machine à 64~bits, on peut les placer aux adresses
    $p.2^{32}$ et elles peuvent grossir chacune jusqu'à 4~Go
  \end{itemizer}
\end{trans}


\begin{trans}{Intérêts de la mémoire virtuelle}
  \begin{itemizer}
  \item Adresse physique des objets pas forcément connue à la compilation
    ni l'édition de lien
  \item Permet de changer adresse d'un objet au chargement ou en cours
    d'exécution
  \item Permet de faire apparaître un objet à \emph{plusieurs} adresses
    (duplication)
  \item Permet simplement d'avoir plusieurs programme simultanément
    chargés en mémoire (multiprogrammation)
  \item Autorise une meilleure gestion de la mémoire : permet de donner
    une vision plus propre de la mémoire\\
    Par exemple peut donner un gros bloc de mémoire à une application même
    si physiquement il n'y a pas assez de mémoire contiguë, sans avoir à la
    compacter
  \item Partage de zones mémoire par plusieurs processus
    \begin{itemizet}
    \item Code si plusieurs instances du même programme
    \item Variables globales si processus légers
    \item Segments de mémoire partagée demandés explicitement par
      différents processus via les IPC (Inter Process Communicarion)
    \end{itemizet}
  \item Permet de virtualiser le concept de mémoire de manière arbitraire
    : cela ressemble à de la mémoire mais c'est un disque, un fichier, un
    écran,...
  \end{itemizer}
  Mémoire virtuelle (traduction d'adresse) généralement effectuée par une
  MMU (\emph{Memory Management Unit})
\end{trans}


\begin{trans}{Grande mémoire virtuelle}
  \begin{itemizer}
  \item En général taille mémoire virtuelle $\gg$ mémoire physique
  \item Comment réaliser la MMU qui calcule une adresse physique sur 40~b
    à partir d'une adresse virtuelle sur 64~b ?
    \begin{align*}
      f : a_v & \longrightarrow a_p\\
      \NN/2^{64}\NN & \longmapsto (\NN/2^{40}\NN)^{2^{64}}
    \end{align*}
    Nécessite une table de $2^{64}$ entrées de 40 bits ! Soit bien plus
    que la mémoire de tout ordinateur \frownie
  \item[\relax {\red \Coffeecup}] Idée 1 : raisonner au grain d'une page de
    taille $t$ et non plus d'une case mémoire :
    \[
    a_p = f(\frac{a_v}{t}) + (a_v \% t)
    \]
    \vavers{} Divise la table de la MMU par $t$ ! Si pages de 4~Ko, plus
    «~que~» $2^{52}$ pages
    \psfiglarge{systemes_exploitation/adressage_pagine.idraw}
  \item[\relax {\red \Coffeecup}] Idée 2 : structure « creuse » : impossible
    qu'un programme non pervers utilise autant de mémoire physique et donc
    de pages \vavers{} ne stocker que les traductions d'adresses (valeurs
    de $f$) pour les pages utiles
  \end{itemizer}
\end{trans}


\begin{trans}{Traduction des adresses des pages}
  Récupère l'adresse de la page physique à la ligne correspondant à
  l'adresse de la page virtuelle
  \begin{center}
    \begin{tabular}{r|c|c|}
      \hline
      & \emph{Existence} & \emph{Page physique}\\\hline\hline
      0 & 0 & \\\hline
      1 & 1 & 0x23fe \\\hline
      2 & 1 & 0x5fde \\\hline
      3 & 1 & 0x2345 \\\hline
      4 & 0 &  \\\hline
      5 & 1 & 0x0 \\\hline
      6 & 0 & \\\hline
       & $\vdots$ & $\vdots$ \\\hline
    \end{tabular}
  \end{center}
  Traduction de l'adresse virtuelle \texttt{0x37890}
  (\begin{tabular}{|c|c|}
    \hline
    3 & 0x7890\\\hline
  \end{tabular}) en adresse physique \texttt{0x23457890} (\begin{tabular}{|c|c|}
    \hline
    0x2345 & 0x7890\\\hline
  \end{tabular})
\end{trans}


\begin{trans}{Tailles de pages}
  Compromis  
  \begin{itemizer}
  \item Petites pages
    \begin{itemizet}
    \item Grande liberté de traduction
    \item Nécessite de nombreuses entrées de traduction
    \end{itemizet}
  \item Grandes pages
    \begin{itemizet}
    \item Utile pour allouer rapidement de grosses zones de mémoire
    \item Petite table des pages
    \end{itemizet}
  \end{itemizer}
  \vavers{} Certains microprocesseurs ont plusieurs tailles de pages
  possibles
\end{trans}


\begin{trans}{Pagination à 3 niveaux sur SPARC}
  \begin{itemizer}
  \item Besoin de compacter la représentation de la table (creuse) de
    traduction
  \item Choix par exemple d'une pagination à 3 niveaux de table dans les
    processeurs
  \item \begin{tabular}{|c|c|c|c|} \hline ind1 & ind2 & ind3 &
      dépl\\\hline
    \end{tabular} traduite en \begin{tabular}{|c|c|}
    \hline
    p & dépl\\\hline
  \end{tabular}
  \end{itemizer}
  \psfiglarge{systemes_exploitation/pagination_SPARC.idraw}
\end{trans}


\begin{trans}{Défaut de page}
  \begin{itemizet}
  \item Si une page n'existe pas (invalide) la MMU génère une interruption
  \item Le système d'exploitation
    \begin{itemizet}
    \item Regarde dans la table des pages s'il existe une traduction
      correcte (fait matériellement par certains processeurs)
    \item Si la page existe mais pas en mémoire physique par exemple, on
      la charge depuis la mémoire secondaire (mécanisme d'échange ou
      \emph{swap})
    \item Éventuellement on évacue des pages depuis la mémoire physique
      (si pages modifiées) pour faire de la place
    \end{itemizet}
  \item Cette interruption peut remonter au niveau de l'application et
    être utilisée (signal \emph{segmentation violation} sous Unix)
  \end{itemizet}
\end{trans}


\begin{trans}{Vision objet de la mémoire virtuelle}
  \begin{itemizer}
  \item Mécanisme de défaut de page : déclenche l'exécution d'une fonction
    quelconque par interruption
  \item Permet de surcharger les « méthodes » \texttt{écriture(\emph{type}
      *\emph{addr}, \emph{type} v)} et \texttt{lecture(\emph{type}
      *\emph{addr})} d'une zone mémoire
  \item Permet de simuler n'importe quel comportement
    \begin{itemizet}
    \item Mémoire artificielle
    \item Émulation d'un autre ordinateur
    \item Mémoire vidéo
    \item Mémoire virtuellement partagée (SVM) transmise ailleurs par
      réseau
    \item ...
    \end{itemizet}
  \end{itemizer}
\end{trans}


\begin{trans}{Mémoire virtuelle et localité}
  \begin{itemizer}
  \item Localité spatiale : si un objet est référencé, des objets proches
    en mémoire seront référencés bientôt (tableaux, structures, variables
    locales, variables d'instances)
  \item Localité temporelle : si un objet est référencé, il sera à nouveau
    référencé (boucles récursivité, ...)
  \end{itemizer}
  \vavers{} Utiliser ces observations pour choisir les pages à échanger
\end{trans}


\begin{trans}{Limiter les défauts de pages}
  Comment éviter que le système passe son temps à traiter des défaut de
  pages ?
 
  \vavers{} Bien choisir la page à vider
  \begin{itemizer}
  \item Réserver un espace à chaque processus dans la mémoire physique\\
    Le processus qui génère un défaut de page cherche une page à vider
    parmi ses propres pages
  \item Ou bien, faire le choix des pages à vider parmi toutes les pages
    en mémoire
  \end{itemizer}
\end{trans}


\begin{trans}{Accélérer la traduction d'adresse}
  \begin{itemizer}
  \item Utiliser une mémoire associative pour stocker les traductions les
    plus courante : cache spécialisé (\emph{Translation Look-aside
      Buffer})
  \item Marche bien car localité spatiale se retrouve au sein d'une page
  \item Table des pages consultée (par le matériel ou le système
    d'exploitation) que lorsque la traduction n'est pas dans le TLB
  \item Le contenu du TLB constitue l'espace de travail (\emph{working
      set}). En cas de changement de processus on intérêt à sauvegarder et
    restaurer ces traductions pour garder la localité
  \end{itemizer}
\end{trans}


\begin{trans}{Contenu d'un TLB}
  \begin{itemizer}
  \item Numéro de page virtuelle
  \item Numéro de page physique
  \item Bit de validité
  \item Bit indiquant si la page a été modifiée par une écriture du
    processeur
  \item Bits de protection (autorisation) d'écriture, de lecture,
    d'exécution
  \item Éventuellement bit indiquant que la page a été lue ou accédée
    (exercice : comment le simuler ?)
  \end{itemizer}
\end{trans}


\begin{trans}{Choix des pages à enlever du TLB}
  Nombreux algorithmes possibles
  \begin{itemizer}
  \item FIFO (première rentrée, première sortie) : un peu violent
  \item NRU (\emph{Not Recently Used}) : régulièrement met à 0 le bit
    indiquant l'accès. Si a la fin du quantum de temps le bit est toujours
    à 0 : candidat à l'éjection
  \item LRU (\emph{Least Recently Used}) : garder la date de dernière
    utilisation de chaque page et virer la plus ancienne
  \end{itemizer}
\end{trans}


\begin{trans}{Donner de l'espace aux processus}
  \begin{itemizer}
  \item Un processus doit avoir suffisamment de pages pour avancer sans
    trop de défauts de pages
  \item Si pas possible, virer de la mémoire centrale un autre processus
    en concurrence
  \item Ne pas libérer des pages partagées par d'autres processus avec le
    processus qui nous intéresse
  \item Ne pas libérer des pages bloquées pour des entrées-sorties
  \item Garder du mou en mémoire centrale pour l'allocation de nouveaux
    espace : existence en tâche de fond d'un démon qui vide des pages
    régulièrement
  \end{itemizer}
\end{trans}


\section{Virtualisation}


\begin{trans}{Architectures virtuelles}
  $\exists$ Différences entre ce que voit l'utilisateur et la réalité
  \begin{itemizer}
  \item Communication par message $\not\Rightarrow$ réseau
    \begin{itemizet}
    \item Paradigme par messages peut utiliser de la mémoire partagée
    \end{itemizet}
  \item Réseau $\not\Rightarrow$ communication par message
    \begin{itemizet}
    \item Paradigme variables partagées au dessus d'un réseau avec des
      messages
    \end{itemizet}
  \end{itemizer}
  \belleboite{Transparence}
  ... \Attention{} ¡\,mais attention parfois aux performances !
\end{trans}


\begin{trans}{Machines virtuelles matérielles}
  \begin{itemizer}
  \item IBM OS/360 : traitement par lots des années 1960
  \item Aller plus loin : volonté de partage de temps
  \item Système à temps partagé :
    \begin{itemizet}
    \item Multiprogrammation
    \item Machine étendue avec interface plus sympathique que la vraie
    \end{itemizet}
  \item[\relax {\red \Coffeecup}] Idée : dissocier les 2
  \item Permet de faire tourner \emph{n'importe quoi} dans la machine
    virtuelle (VM \emph{virtual machine})
  \item Programme utilisateur dans chaque VM/370, voire un autre système
    d'exploitation dans VM/370 : CMS spécialisé pour l'interactif,
    Unix,...
  \end{itemizer}
\end{trans}


\begin{trans}{Intérêts de la virtualisation}
  \begin{itemize}
  \item Sécurité
    \begin{itemize}
    \item Attaques cernèes dans la VM
    \item 1 VMM prouvé qui délimite des VM avec des OS non prouvés
    \end{itemize}
  \item Factorisation ressources
    \begin{itemize}
    \item Machines (pas la peine d'avoir 1 Mac + 1 PC sous Windows + 1 Sun
      sous Solaris + 1 truc sous Linux +...)
    \item Processeurs
    \item Disques
    \item Interfaces réseau
    \end{itemize}
  \item Administration simplifiée
    \begin{itemize}
    \item 1 administration + clonage
    \end{itemize}
  \item Tolérance aux pannes
    \begin{itemize}
    \item Migration de machines virtuelles complètes en cas de panne ou de
      charge trop élevée
    \item Snapshot d'état
    \end{itemize}
  \item SOA (Service-Oriented Architecture)
    \begin{itemize}
    \item Infrastructures à la demande
    \item Hébergement moins cher
    \item Mutualisation
    \end{itemize}
  \item Permet de faire tourner vieilles applications sur matériel qui
    n'existe plus (autocom Alcatel, musées de l'informatique...)
  \item Mise au point de pilotes ou OS sous débogueur dans VM
  \item Recherche en architecture : simulation au cycle près sans vrai
    matériel
    \begin{itemize}
    \item Projet de processeur CryptoPage à TÉLÉCOM Bretagne
    \end{itemize}
  \item Co-conception (\emph{codesign}) OS-matériel
  \end{itemize}
  ... Au prix d'une $\pm$ légère perte d'efficacité
\end{trans}


\begin{trans}{Machines virtuelles logicielles}
  \begin{itemizer}
  \item Principe encore vivant :
    \begin{itemizet}
    \item JVM : Java \vavers{} JVM \emph{compile once, run everywhere}
    \item Langages PERL (Parrot), Python, C\# (CDL),...
    \item Emacs
      \begin{itemizet}
      \item Langage de programmation Emacs-LISP, interpréteur et machine
        virtuelle (exécute du \emph{bytecode})
      \item Système d'exploitation portable : processus,
        intercommunication,...
      \item Système de multi-fenêtrage
      \item Peut aussi servir d'éditeur de texte... \smiley
      \end{itemizet}
    \item Faire tourner des PCs virtuels dans des PCs : VMware, QEMU,
      vieux \emph{ple}x86 \LienPDF{http://www.plex86.org/},...
    \item Faire tourner des PCs sur n'importe quoi (PC, Mac, Sun,...) :
      BOCHS \LienPDF{http://www.bochs.com/}, QEMU, PTLsim (précis au cycle
      près)...
    \item \LienPDF{http://www.deanliou.com/WinRG/WinRG.htm} «
      \emph{Microsoft's Windows RG (Really Good Edition)} » de James
      \textsc{Cliffe} : des applications Windows dans Windows RG en Flash
      qui tourne dans une machine virtuelle Flash qui tourne dans un
      navigateur WWW qui tourne dans un processus qui tourne sur un
      processeur physique (qui tourne dans...)
    \end{itemizet}
  \end{itemizer}
\end{trans}


\begin{trans}{Machines virtuelles - fonctionnement}
  \begin{itemizer}
  \item Moniteur de machine virtuelle juste au dessus du matériel
  \item Prend en charge la multiprogrammation
  \item Copie conforme de matériel si bas niveau : simule
    \begin{itemizet}
    \item Modes noyau, utilisateur
    \item Mémoire virtuelle
    \item Interruptions
    \item Dispositifs virtuels d'entrée sortie : lèvent une interruption
      et la machine physique fait l'opération
    \item Lecture de secteurs disques sur un disque virtuel en commandant
      le contrôleur disque virtuel (\emph{minidisk} sur IBM VM 370)
    \item Écriture dans la mémoire écran : déclenche une exception au
      moment de l'écriture dans la mémoire \vavers{} transformé en
      écriture dans une fenêtre de l'écran physique
    \end{itemizet}
  \item L'aspect multiprogrammation reste simple : commuter des machines
    virtuelles
  \item \Attention{} Difficile à optimiser
    \begin{itemizet}
    \item Fait tourner 2 processus identiques sur 2 OS identiques en même
      temps sans partage de pages...
    \item Écriture dans l'écran virtuel même si fenêtre non visible...
    \end{itemizet}
  \item VMware \& QEMU : simule plusieurs machines $x$86 sur une machine
    $x$86
    \begin{itemizet}
    \item Utilise le $x$86 sous-jacent pour exécuter la majorité du code
      \vavers{} rapide
    \item Mémoire simulée par la mémoire virtuelle via la MMU
    \item Périphériques détournés par la MMU et simulés
    \end{itemizet}
  \item BOCHS \LienPDF{http://www.bochs.com/} : simulateur complet de
    machine virtuelle à processeur $A$ sur processeur $B$
    \begin{itemizet}
    \item Instructions de $A$ interprétées par $B$ ou traduites
      (compilées) et exécutées par $B$
    \item Mémoire et périphériques gérés par l'interpréteur
    \end{itemizet}
  \item Nouveaux processeurs rajoutent des instructions pour virtualiser
    de manière efficace instructions superviseurs
    \begin{itemize}
    \item AMD Pacifica, Intel VT
    \item Il faut aussi virtualiser matériel car si requêtes DMA et ES
      partent sur bus \alert{physiques}... \frownie\\
      \vavers Apparition de matériel qui gère virtualisation
      \begin{itemize}
      \item Interfaces Ethernet physique gérant plusieurs Ethernet
        virtuels
      \item Canaux DMA gérant virtualisation et MMU virtuelle
      \end{itemize}
    \end{itemize}
  \end{itemizer}
  Cf. biblio
\end{trans}


\begin{trans}{Paravirtualisation}
  \begin{itemize}
  \item Faire tourner un OS dans une machine virtuelle est difficile
    \begin{itemize}
    \item Un OS ne suppose pas qu'il doit économiser le processeur
    \item Dispositifs d'E/S gèrent rarement virtualisation
    \end{itemize}
  \end{itemize}
  \begin{alertblock}{{\red \Coffeecup} Idée {\red \Coffeecup}}
    Modifier OS pour prendre en compte machine virtuelle hôte \vavers
    \alert{paravirtualisation}
  \end{alertblock}
  Exemple : Xen qui tourne dans un OS hôte pour bénéficier infrastructure
  (gestion mémoire, périphériques...)
  \begin{itemize}
  \item Modification ordonnanceur pour passer la main aux autres OS
  \item Modification pilotes de périphériques pour passer la main à
    périphériques (gros du boulot, source de bugs et baisse de
    performance)
  \item OS hôte tourne dans « domaine » 0
  \end{itemize}
  Nécessite d'avoir sources de l'OS...
\end{trans}


\section{Les entrées-sorties}


\subsection{Systèmes de fichiers}


\begin{trans}{Hiérarchie de classes de fichiers Unix simplifiée}
  \psfiglarge{systemes_exploitation/hierarchie_fichier_UML.eps}
\end{trans}


\begin{trans}{Descripteur de fichier}
  \begin{itemizer}
  \item Fichier désigné par un chemin (nom) absolu (\texttt{/bin/sh}) ou
    relatif au répertoire courant du processus (\texttt{essai.c})
    \begin{itemizet}
    \item Chaînes de caractères sont traitées inefficacement par les
      processeurs : pénible
    \item Fichier $\equiv$ objet dans système d'exploitation. Sous Unix :
      \begin{itemizet}
      \item Contient une référence au système de fichiers contenant ce
        fichier
      \item Contient une référence au v-n\oe{}ud (\emph{v-node}) du
        fichier dans son système de fichier. v-n\oe{}ud implémenté par
        exemple par un i-n\oe{}ud
      \end{itemizet}
    \item Comment manipuler depuis n'importe quel langage (orienté objet
      ou non) ?
    \end{itemizet}
  \item  Besoin d'état par accès et non plus par fichier :
    \begin{itemizet}
    \item Stocke un pointeur de lecture/d'écriture courante
    \item Des droits d'accès
    \end{itemizet}
  \item Idée en Unix : accéder à chaque fichier à partir d'un entier
    (positif), le \emph{descripteur de fichier}, représentant l'objet
    d'accès au fichier et non le fichier lui-même
  \item Association d'un chemin d'accès à un descripteur de fichier =
    \emph{ouvrir} un fichier
\begin{exemple}
int fd = open(char *path, int flags, int perms)  
\end{exemple}
\begin{itemizet}
\item \texttt{flags} permet de choisir de pouvoir faire des lectures ou
  écritures par la suite, de créer un nouveau fichier,...
\item \texttt{perms} permet de changer les droits par défaut (fichier
  exécutable ? Mon voisin a le droit de le lire ?...)
\end{itemizet}
\item Désassociation d'un descripteur de fichier lorsqu'on n'en a plus
    besoin = \emph{fermer} un fichier
\begin{exemple}
int close(int fd)  
\end{exemple}
  \end{itemizer}
\end{trans}


\begin{trans}{Sémantique des fichiers Unix}
  \begin{itemizer}
  \item Un fichier sous Unix peut être utilisé par plusieurs processus en
    même temps
  \item Il y a autant de descripteur qu'il y a d'utilisations différentes
    du fichier
  \psfiglarge{systemes_exploitation/2fd.eps}
  \item Les écritures ou lectures sont atomiques
  \item On a aussi des mécanismes de verrous (indicatifs, obligatoires,
    bloquants ou non) via l'appel \texttt{fcntl()}
  \end{itemizer}
\end{trans}


\begin{trans}{Quelques méthodes associées à des fichiers}
  Cf \texttt{man \emph{[}-s\emph{]} 2}, outre \texttt{open()} et
  \texttt{close()} déjà vus à utiliser avec
\begin{exemple}
#include <unistd.h>
\end{exemple}
  \begin{itemizer}
  \item \verb|ssize_t read(int fd, void *buf, size_t count)| : lit à
    partir de la position courante au plus \texttt{count} caractères
  \item \verb|ssize_t write(int fd, const void *buf, size_t count)| essaye
    d'écrire \texttt{count} caractères
  \item \verb|off_t lseek(int fildes, off_t offset, int whence)| déplace
    le point courant en absolu, relatif ou depuis la fin selon
    \texttt{whence}
  \item \verb|int stat(const char *file_name, struct stat *buf)| :
    récupère toutes les caractéristiques d'un fichier
  \item \texttt{int fstat(int fd, struct stat *buf)} : idem sur un fichier
    ouvert
  \item \verb|int lstat(const char *file_name, struct stat *buf)| : idem
    mais dans le cas d'un lien analyse le lien au lieu de la cible
  \item \texttt{int symlink(const char *oldpath, const char *newpath)} :
    crée un lien symbolique
  \item \texttt{int link(const char *oldpath, const char *newpath)} crée
    un lien \emph{hard} (une nouvelle entrée) dans un répertoire pour un
    fichier déjà existant
  \item \texttt{int unlink(const char *pathname)} supprime une entrée d'un
    répertoire, voire efface le fichier
  \item \texttt{int pipe(int filedes[2])} crée une paire de descripteurs
    de fichier : on peut lire dans \texttt{filedes[0]} ce qu'on écrit dans
    \texttt{filedes[1]}
  \item \texttt{int socket(int domain, int type, int protocol)} crée un
    descripteur de fichier de communication
  \end{itemizer}
  \Attention{} Quelques blagues avec les gros fichiers (>2Go) sur un
  ordinateur ne manipulant pas des données 64 bits (32 bits...) :
  nécessité de proposer une version 32 et 64 bits de certains appels
  systèmes... \frownie
\end{trans}


\begin{trans}{Passe un descripteur à ton voisin}
  Et si on veut partager un fichier ET l'endroit courant ?
  \begin{itemizer}
  \item \vavers{} Partage du \emph{même} descripteur de fichier
  \item Duplication d'un descripteur via \texttt{dup()} et \texttt{dup2()}
  \item Naturellement dupliqués via le clonage (\texttt{fork()})
  \item Hérité via \texttt{exec()} : base du shell qui peut manipuler les
    fichiers de ses enfants pour gérer \texttt{|}, \texttt{<} ou
    \texttt{>}...\\
    Conventions de numérotation des descripteurs de fichier pour un
    processus Unix :
    \begin{itemizet}
    \item 0 : entrée standard (stdin)
    \item 1 : sortie standard (stdout)
    \item 2 : sortie pour les messages d'erreur (stderr, en général non
      tamponnée dans les bibliothèques)
    \end{itemizet}
    Un processus peut ne connaître que ces descripteurs alors que c'est le
    shell qui leur a associé des fichiers ou autres
  \end{itemizer}
\end{trans}


\begin{trans}{Les fonctions d'E/S du C(++)}
  Le C (\texttt{stdio.h}) ou les \texttt{stream} de C++ en rajoute une
  couche\\
  Remarque : cela fait partie de la bibliothèque, pas vraiment du système
  d'exploitation...
  \begin{itemizer}
  \item \texttt{read}, \texttt{write},... : assez bas niveau
  \item Ces appels systèmes provoquent un passage dans le noyau à chaque
    fois : lourd
  \item Besoin de fonctions légères et de plus haut niveau : tamponne les
    entrées-sorties et envoie le tout par bloc \vavers{} moins de passage
    dans le noyau
  \item \texttt{\emph{[}f\emph{]}printf()}
  \item \texttt{\emph{[}f\emph{]}scanf()}
  \item \texttt{fopen()}
  \item \texttt{fclose()}
  \end{itemizer}
\end{trans}


\subsubsection{Disques}



\begin{trans}{( Disques magnétiques )}
  \centerline{\includegraphics[height=0.8\vsize]{systemes_exploitation/disque_dur_couleur.idraw}}
\end{trans}


\begin{trans}{Unix FFS optimisé pour les disques}
  \begin{itemizer}
  \item Partition (ou tranche) : ensemble de cylindres consécutifs \vavers
    $\nearrow$ localité
  \item Allocation dans des cylindres consécutifs
  \item Allocation dans des secteurs consécutifs avec un saut (temps
    de rotation)
  \item Laisse des cylindres vides régulièrement pour allouer plus
    rapidement de nouveaux secteurs
  \end{itemizer}
  Problèmes des caches dans les contrôleurs disque qui éloignent de la
  réalité...
\end{trans}


\begin{trans}{Partitionnement des disques}
  \begin{itemizer}
  \item Découpe des disques pour des usages différents
  \item Augmente la localité (et donc performances) des accès au sein de
    chaque partition
  \item Limites infranchissables (contre certains utilisateurs expansifs)
  \item Fournit des zones brutes pouvant avoir chacune leur système de
    fichier (indépendant et même de type différent) voir sans (swap, base
    de donnée)
  \item Peuvent avoir des politiques d'exportation différentes sous NFS
  \item \Attention{} Éviter d'avoir 2 partitions qui se recouvrent sans
    raison...
  \item Partitionnement fait automatiquement et graphiquement par la
    procédure d'installation
  \item Mais en cas de problème sur un disque, de remplacement, de
    changement du partitionnement : connaissance utile
  \item Chaque système d'exploitation a sa convention de partitionnement
    (n'est pas déterminé au niveau du disque lui-même)
  \item Solaris découpe en 8 ou 10 partitions avec comme convention
    l'usage courant
    \begin{description}
    \item[0 :] contient \texttt{/}
    \item[1 :] du swap
    \item[2 :] tout le disque (déborde sur les autres...)
    \item[3 :] \texttt{/export} sur un serveur
    \item[4 :] \texttt{/export/swap} sur un serveur
    \item[5 :] \texttt{/opt}
    \item[6 :] \texttt{/usr}
    \item[7 :] \texttt{/home} ou \texttt{/export/home}
    \item[8 :] sur PC contient le système de boot et pointe au début du
      disque
    \item[9 :] sur PC contient les blocs alternatifs utilisés à la place
      d'autres en panne et pointe après la partition 8
    \end{description}
  \item Sur PC nécessité d'une «~convention collective des OS~» pour faire
    du multi-OS. Convention de partitionner un disque jusqu'en 4
    partitions via \texttt{fdisk}. Solaris prend une de ces partitions et
    la repartitionne avec son propre système
  \item \Attention{} La loi de Murphy veut que le partitionnement choisi
    n'est jamais le bon... En général, \texttt{/} et le swap sont trop
    petits
  \item \Attention{} Loi de Murphy numéro 2 : difficile de changer le
    partitionnement dynamiquement...
  \end{itemizer}
\end{trans}


\subsubsection{Formattage}


\begin{trans}{Utilitaire format}
  Utilisation :
  \begin{itemizer}
  \item Installation d'un nouveau disque :
    \begin{itemizet}
    \item Formattage
    \item Partitionnement
    \end{itemizet}
  \item Affiche les disques reconnus sur le système
  \item Affiche des informations et leur partitionnement 
  \item Test d'un disque
  \item Réparation d'un disque
  \item Destruction du contenu (sensible...) avant renvoi
  \end{itemizer}
\end{trans}


\begin{trans}{format à l'\oe{}uvre}
  Les commandes sont abrégeables
  \begin{itemizer}
  \item \texttt{partition} gère et affiche le partitionnement
    (\texttt{prtvtoc} donne aussi l'information) {\footnotesize
\begin{verbatim}
partition> p
Current partition table (original):
Total disk cylinders available: 253 + 2 (reserved cylinders)

Part      Tag    Flag     Cylinders       Size            Blocks
  0       root    wm       3 -  28      203.95MB    (26/0/0)   417690
  1       swap    wu      29 - 170        1.09GB    (142/0/0) 2281230
  2     backup    wm       0 - 252        1.94GB    (253/0/0) 4064445
  3 unassigned    wm       0              0         (0/0/0)         0
  4 unassigned    wm       0              0         (0/0/0)         0
  5 unassigned    wm       0              0         (0/0/0)         0
  6        usr    wm     171 - 252      643.23MB    (82/0/0)  1317330
  7 unassigned    wm       0              0         (0/0/0)         0
  8       boot    wu       0 -   0        7.84MB    (1/0/0)     16065
  9 alternates    wu       1 -   2       15.69MB    (2/0/0)     32130
\end{verbatim}
      } Adresses aussi en \emph{cylindre}/\emph{tête}/\emph{bloc}

    Format propose un partitionnement par défaut
  \item \texttt{current} décrit le disque courant
\begin{verbatim}
format> cu
Current Disk = c0t4d0: bassine
<SEAGATE-ST39102LW-0004 cyl 6922 alt 2 hd 12 sec 214>
/sbus@1f,0/espdma@e,8400000/esp@e,8800000/sd@4,0
\end{verbatim}
  \item \texttt{format} reformate le disque
  \item \texttt{backup} récupère un label (la table des matières du
    disque) de secours en cas de perte du label principal
  \item \texttt{analyse} permet de tester le disque avec un effet plus ou
    moins destructeur
  \item \texttt{repair} répare 1 bloc du disque en le rajoutant dans la
    liste des défectueux et en remet un autre à la place. En cas de
    problème matériel
  \item \texttt{defect} permet de gérer la liste des défauts (1 gros
    disque est rarement parfait...)
  \item \texttt{volname} donne un nom au disque. Au CRI on donne des noms
    de conteneurs pour s'y retrouver. \texttt{goutte} aura moins d'octets
    que \texttt{bassine}. Même nom qu'on retrouve monté
  \item \texttt{label} entérine les modifications
  \end{itemizer}
  \texttt{/etc/format.dat} contient les paramètres de formatage
  (géométrie, etc) des disques connus
  \begin{itemizer}
  \item Disque récent (SCSI-2) en bon état : informe directement
    \texttt{format}
  \item Sinon, lire la documentation ou récupérer un \texttt{format.dat} récent (ou
    le contraire !)
  \end{itemizer}
\end{trans}


\begin{trans}{Étape fdisk sur PC}
  \begin{itemizer}
  \item Partage du disque disque entre plusieurs OS
    {\scriptsize
\begin{verbatim}
             Total disk size is 788 cylinders
             Cylinder size is 16065 (512 byte) blocks

                                               Cylinders
      Partition   Status    Type          Start   End   Length    %
      =========   ======    ============  =====   ===   ======   ===
          1                 IFS: NTFS         0    50      51      6
          2                 DOS-BIG          51   101      51      6
          3       Active    Solaris         102   356     255     32
          4                 UNIX System     357   592     236     30



SELECT ONE OF THE FOLLOWING:

   1. Create a partition
   2. Specify the active partition
   3. Delete a partition
   4. Exit (update disk configuration and exit)
   5. Cancel (exit without updating disk configuration)
Enter Selection: 
\end{verbatim}
      }
  \item 1 seule partition Solaris par disque
  \item Partition Solaris alignée sur 1 cylindre
  \item Épargner le \emph{Master Boot Record} sur le cylindre 0
  \item Subtilité
    \begin{enumerate}
    \item On formate le disque avec \texttt{format}
    \item On partitionne globalement avec \texttt{fdisk} appelable
      directement depuis \texttt{format}
    \item On partitionne la partition Solaris générée avec \texttt{format}
      à nouveau...
    \end{enumerate}
  \item Mode non interactif pour extraire des configurations et configurer
    de manière précise un disque brute style \texttt{/dev/rdsk/c0t0d0p0}.
    Intérêt pour faire des installations automatiques multi-système
    d'exploitation
  \end{itemizer}
\end{trans}


\begin{trans}{Interface de système de fichier VFS}
  Le Virtual File System permet un héritage au sens objet
  \psfiglarge{systemes_exploitation/heritage_VFS.eps}
\end{trans}


\begin{trans}{Montage/démontage d'un système de fichiers}
  \begin{itemizer}
  \item Pour accéder à un système de fichier : montage pour attacher le
    système à un répertoire de la hiérarchie préexistante
    \begin{multicols}{2}
      \psfiglarge{systemes_exploitation/Administration_Unix/hierarchie_UNIX.idraw}
      \psfiglarge{systemes_exploitation/Administration_Unix/hierarchie_UNIX_montage.idraw}
    \end{multicols}
  \item \texttt{/} est toujours monté (lancement du noyau) et indémontable
  \item Montage cache les fichiers préexistants dans le répertoire
  \item Démontage du système de fichier fait réapparaître d'éventuels
    fichiers préexistants
  \item Démontage possible seulement si plus aucun process n'utilise le
    système de fichier
  \item Démontage utile pour faire une sauvegarde d'une partition en étant
    sûr que personne ne la modifie
  \item Arrêt du système utilise une procédure de démontage
  \end{itemizer}
\end{trans}


\begin{trans}{Structure de système de fichier Unix}
  \psfiglarge{systemes_exploitation/systeme_fichiers_Unix_UML.eps}
\end{trans}


\begin{trans}{Structure de répertoire virtuel Unix}
  \begin{center}
    \begin{tabular}{|r|l|}
      \hline
      \emph{inode} & \emph{Nom}\\\hline\hline
      12345 & \texttt{.}\\\hline
      67890 & \texttt{..}\\\hline
      2004 & \texttt{toto}\\\hline
      4 & \texttt{Schtroumfette\_nue.divX}\\\hline
    \end{tabular}
  \end{center}
\end{trans}


\begin{trans}{Transformer de la mémoire disque en fichiers}
  \begin{itemizer}
  \item Langages de programmation de haut niveau : manipulation de
    structure de données, d'objets,... Assez loin de la vraie vie de
    l'occupation mémoire (sauf pour celui qui écrit le compilateur
    \smiley)
  \item Dans un système de fichier : aplatir une structure de donnée sous
    forme de flux d'octets ou de blocs de données
  \item Compromis à trouver
    \begin{itemizet}
    \item Minimum de surcoût mémoire
    \item Rapidité d'accès en lecture ou écriture
    \item Possibilité de rajouter ou d'enlever des fichiers sans (trop)
      fragmenter la mémoire
    \item Tolérance aux pannes (redondance)
    \item Optimisation de cas courants ou pas (gros fichiers
      séquentiels,...)
    \item ...
    \end{itemizet}
  \end{itemizer}
\end{trans}


\begin{trans}{Transformer de la mémoire disque en fichiers Unix}
  \begin{itemizer}
  \item Unité de base : le bloc
  \item Peut contenir des données ou des pointeurs vers d'autres blocs
  \end{itemizer}
  \psfiglarge{systemes_exploitation/blocs_fichier_Unix.eps}
\end{trans}


\begin{trans}{Structure globale du FFS}
  \centerline{\includegraphics[height=0.8\vsize]{systemes_exploitation/structure_Disque_FFS.eps}}
\end{trans}


\begin{trans}{Systèmes de fichiers sous Solaris}
  \begin{itemizer}
  \item Utilise le Virtual File System : définit une interface permettant
    de rajouter assez simplement un nouveau type de système de fichiers
  \item Masque les détails : possibilité de lire, écrire, consulter, etc.
    quel que soit le type de système de fichiers (local, distant,...)
  \item Systèmes de fichiers de type disque local
    \begin{description}
    \item[UFS :] Unix File System, basé sur le FFS 4.3BSD, Système de
      fichier par défaut
    \item[HSFS :] High Sierra et ISO-9660 (version officielle de la
      précédente) pour CD-ROM. Lecture seule. Extension Rock Ridge
      fournissant la sémantique UFS (sauf les liens durs et...
      l'écriture~!)
    \item[PCFS :] lecture et écriture sur des disques au format MS-DOS
      (typiquement disquettes)
    \item[S5FS :] lecture et écriture sur des disques au format System V
      sur PC
    \end{description}    
  \item Système de fichiers de type accès distant
    \begin{description}
    \item[NFS :] Network File System pour accéder à des fichiers distants
      comme s'ils étaient locaux (modulo des différences de performance)
    \end{description}    
  \item Système de fichiers virtuels
    \begin{description}
    \item[CacheFS :] Cache File System pour stocker localement une copie
      rapide. CD-ROM, Intranet distant,...
    \item[TMPFS :] Temporary File System pour stocker en mémoire pour
      aller très vite. Configuration par défaut de \texttt{/tmp}
      (accélération des compilations...) qui est doublement volatil
    \item[LOFS :] Loopback System pour faire apparaître à un autre endroit
      une partie de la hiérarchie (y compris montages NFS)
    \item[PROCFS :] Process System montre la liste des processus en train
      de tourner sous forme de répertoires. Utilisé par des outils de
      debug et d'analyse
    \item 5 autres systèmes de fichiers à usage interne sans
      administration particulière
    \end{description}    
  \item LOFI \emph{Loopback file driver} permet de générer un pilote brut
    à partir d'une image fichier
    \begin{itemizet}
    \item Montage de l'image d'un CD-ROM
\begin{verbatim}
lofiadm -a $CD/sol-8-u5-sparc-v1.iso
mount -F hsfs -o ro /dev/lofi/1 /mnt
\end{verbatim}
%$
    \item Montage de l'image d'une disquette
    \end{itemizet}
  \item Tâche de l'administrateur ?
    \begin{itemizet}
    \item Créer de nouveaux systèmes de fichiers
    \item Rendre les ressources locales et distantes accessibles aux
      utilisateurs
    \item Connexion et ajout de nouveaux disques
    \item Mise en place d'une \emph{excellente} politique de sauvegarde
    \item Vérification et correction des fichiers endommagés\\
      Pour les hackers : \texttt{fsdb} un debogueur de système de fichiers
      pour récupérer un accident...
    \end{itemizet}
  \item Commandes générique : \texttt{mount}, \texttt{umount},
    \texttt{mkfs}, \texttt{fsck},... acceptent l'option \texttt{-F
      \emph{fs-type}} et appellent en fait \texttt{mount},
    \texttt{umount\_\emph{fs-type}}, \texttt{mkfs\_\emph{fs-type}},
    \texttt{fsck\_\emph{fs-type}},... Voir les documentations de ces
    dernières commandes pour les détails intrinsèques
  \end{itemizer}
\end{trans}


\begin{trans}{UFS journalisé}
  \begin{itemizer}
  \item Unix File System est celui utilisé par défaut sous Solaris.
    Extension du FFS 4.3BSD. La partition est divisée en groupes de
    cylindres
    \begin{description}
    \item[Boot Block] 8 Ko permettant le démarrage. Existe même si pas
      partition de boot
    \item[Superblock] contient les informations sur le système de fichier
      : taille, statut, label, taille des blocs, date de dernière
      modification, nom du dernier répertoire de montage, etc.\\
      Contient des drapeaux précisant le fonctionnement
      \begin{description}
      \item[État] \emph{clean}, \emph{stable}, \emph{active},
        \emph{logging} et \emph{unknown}. Permet de savoir où en est le
        disque lors d'un accident. \emph{clean}, \emph{stable} ou
        \emph{logging} ne nécessite pas de \texttt{fsck}
      \item[Extended Fundamental Type (EFT)] pour avoir des numéros
        d'utilisateurs, de groupes et de devices sur 32 bits
      \item[Large file systems] système de fichiers de 1 To en tout.
        Pratique si stripping/RAIDs à la DiskSuite
      \item[Large files] pour fichiers dépassant les 2 Go. Par défaut
      \end{description}    
      Comme l'information des superblocs est critique, elle est répliquée
      dans tous les groupes de cylindres et décalée de telle manière
      qu'elle soit répartie en plus sur tous les plateaux
    \item[Inodes] contiennent toutes les informations sur un fichier sauf
      son nom : type (normal, répertoire, device,...), mode, propriétaire
      et groupe, taille, dates,... et tableau de 15 adresses de blocs de
      données. L'adresse 13 pointe vers un bloc d'adresses, l'adresse 14
      pointe vers un bloc d'adresses de blocs d'adresses et l'adresse 15
      encore un niveau de plus pour les très gros fichiers
    \item[Blocs de données] stockent le contenu des fichiers et des
      répertoires (fichiers de noms et d'adresses d'inodes). Blocs de
      taille 8 Ko ou 1 Ko (fragments) par défaut
    \item[Blocs libres] blocs non utilisés (ni inodes, ni données, ni
      blocs d'adresse) par groupe de cylindre. Garde trace de la
      fragmentation pour limiter sa propagation
    \end{description}
    Pour des raisons de performance, on arrête le remplissage du disque à
    90~\% de la capacité pour ne pas perdre trop de temps à chercher de la
    place
  \item Journalisation
    \begin{itemizet}
    \item Penser les modifications aux fichiers sous forme de transactions
    \item Stocker les transactions dans un journal
    \item Appliquer (plus tard) les transactions au système de fichier
    \item Après accident, lors du redémarrage les transactions incomplètes
      sont éliminées mais les transactions complètes sont prises en compte
      \vavers{} cohérence maintenue
    \item Plus besoin de faire tourner de longs \texttt{fsck} au démarrage
    \item Démarré par option \texttt{-o logging} au montage
    \item Le journal est alloué dans la liste de blocs vides
    \end{itemizet}
  \item \texttt{mkfs -F ufs} permet de créer un système de fichier en
    spécifiant tous les paramètres
  \item \texttt{newfs} crée un système de fichier standard en appelant
    \texttt{mkfs -F ufs} avec des paramètres par défaut
    {\scriptsize
\begin{verbatim}
deauville-root > newfs -v /dev/rdsk/c0t4d0s5
newfs: construct a new file system /dev/rdsk/c0t4d0s5: (y/n)? y
mkfs -F ufs /dev/rdsk/c0t4d0s5 5926944 214 12 8192 1024 64 2 167 6144 t 0 -1 8 128
/dev/rdsk/c0t4d0s5:     5926944 sectors in 2308 cylinders of 12 tracks, 214 sectors
        2894.0MB in 61 cyl groups (38 c/g, 47.65MB/g, 7936 i/g)
super-block backups (for fsck -F ufs -o b=#) at:
 32, 97840, 195648, 293456, 391264, 489072, 586880, 684688, 782496, 880304,
 978112, 1075920, 1173728, 1271536, 1369344, 1467152, 1561376, 1659184,
 1756992, 1854800, 1952608, 2050416, 2148224, 2246032, 2343840, 2441648,
 2539456, 2637264, 2735072, 2832880, 2930688, 3028496, 3122720, 3220528,
 3318336, 3416144, 3513952, 3611760, 3709568, 3807376, 3905184, 4002992,
 4100800, 4198608, 4296416, 4394224, 4492032, 4589840, 4684064, 4781872,
 4879680, 4977488, 5075296, 5173104, 5270912, 5368720, 5466528, 5564336,
 5662144, 5759952, 5857760,
\end{verbatim}
      } Il peut être utile de stocker cette information pour avoir
    l'adresse des superblocs en cas de coup dur.
  \item \texttt{tunefs} permet de fignoler les paramètres après coup.
    Moins utile avec tous les caches des disques
  \end{itemizer}
\end{trans}


\begin{trans}{Vérification d'un système de fichiers}
  \begin{itemizer}
  \item Beaucoup de choses sont faites de manière asynchrone pour
    accélérer un système de fichiers. \texttt{fsflush} effectue les
    écritures en tâche de fond
  \item \texttt{sync} re-synchronise les disques avec ce que pense
    l'utilisateur (utile si obligé d'arrêter salement une machine)
  \item Suite à un reboot intempestif ou une panne matérielle, structures
    de données incohérentes dans le système de fichier : fichiers à
    moitiés effacés, superbloc endommagé,...
  \item Lancement d'un \texttt{fsck} au démarrage si un système de fichier
    n'est pas marqué \emph{clean} (démonté proprement à l'arrêt),
    \emph{stable} (non démonté proprement à l'arrêt mais non modifié après
    le dernier \texttt{sync} ou \texttt{fsflush} avant l'arrêt) ou
    \texttt{log} (système de fichier journalisé). Parcours de toute la
    structure du disque : long ! Mais analyse de plusieurs disques en
    parallèle
    \begin{itemizet}
    \item Corrige le superbloc (taille, nombre d'inodes, nombre de blocs
      et d'inodes libres)
    \item Peut récupérer un superbloc de secours. Si le système est trop
      HS pour savoir où le trouver, chercher si vous n'avez pas la sortie
      de \texttt{newfs} quelque part sinon faire un \texttt{newfs~-N} du
      disque pour faire un système de fichiers pour de faux
    \item Vérification des inodes (nombre de liens vers l'inode, taille,
      blocs de données référencés 2 fois)
    \item Correction des répertoires «~\texttt{.}~» et «~\texttt{..}~»
      dans les répertoires
    \item ...
    \item Si fichiers et répertoires (inodes) non référencés dans un
      répertoire : reliés à \texttt{lost+found}
    \end{itemizet}
  \item Certains problèmes sont insolubles automatiquement : choix
    \vavers{} questions à l'utilisateur. Possibilité de faire un
    \texttt{fsck} à la main (sur un système de fichier inactif !) avec\\
    \texttt{fsck /dev/rdsk/\emph{device-name}}
  \item \Attention{} \texttt{fsck} n'a aucun moyen de réparer le
    \emph{contenu} des fichiers...
  \item \Attention{} Ne pas monter a priori de disque local via
    \texttt{/etc/vfstab} sans préciser que le \texttt{fsck} doit être fait
    au démarrage. Un \texttt{-} dans \texttt{/etc/vfstab} indique pas de
    \texttt{fsck}, \texttt{1} pour \texttt{fsck} séquentiel dans l'ordre du
    \texttt{/etc/vfstab} et plus que 1 pour dire que les fsck sont ensuite
    faits en parallèle sur les disques
  \item \Attention{} \texttt{fsck} ne remplace pas les RAID et encore
    moins les sauvegardes ! Évite juste les restaurations en cas de
    problèmes mineurs
  \item Pour hackers et pompiers le débogueur de système de fichiers :
    \texttt{fsdb}, \texttt{fsdb\_ufs},...
  \end{itemizer}
\end{trans}


\subsubsection{RAID}


\begin{trans}{RAID}
  Augmenter débit et capacité mais diminuer coût $\leadsto$
  paralléliser les disques !

  Problème : {\em Mean Time Between Failure} de plusieurs disques.
  
  Endurance de $N$ disques pendant un temps $t$ :
  \[
  R_N(t)= (R_1(t))^N
  \]

  Est-ce bien utile ?
  \[
  \lim_{N \rightarrow \infty} R_N(t) = 0
  \]
  Si $MTBF_1=30000$ heures, alors $MTBF_{1000}=30$ heures...
\end{trans}


\begin{trans}{Redundant Array of Inexpensive Disks}
  \belleboite{Mettre plus de disques pour compenser les pannes}

  \begin{multicols}{2}
    Chaîne de \textsc{Markov} modélisant un RAID où 0 ou 1 disque peut
    être en panne sans perte de données :
    \begin{itemizer}
    \item $\lambda$ constante de panne d'un disque ($1/\mathit{MTBF}_1$)
    \item $\mu$ constante de réparation. Supposition : $\lambda \ll \mu$
    \end{itemizer}
    \begin{center}
      \input{dessins/RAID_Markov.texfig}
    \end{center}
  \end{multicols}
  Durée avant perte de données :
  \[
  \textit{MTTDL}\approx \frac{\mu}{N\times (N+1)\lambda ^2}
  \]
\end{trans}


\begin{trans}{Types de RAIDs}
  \begin{description}
  \item[RAID-0 :] pas de redondance ! \emph{stripping} sur plusieurs disques
  \item[RAID-1 :] tout est doublé
    \begin{itemizer}
    \item cher : moitié du disque utile
    \item rapide
    \end{itemizer}
  \item[RAID-2 :] rajouter $ C$ disques par $D$ disques pour
    code de détection et correction d'erreur, $C \geq \log_2(D+C+1)$
  \item[RAID-3,4,5 :] si un contrôleur sait quand le disque est en panne
    (\textsc{crc} sur disque, etc.) $\leadsto$ seule la parité suffit.
    
    \begin{align}
      \label{eq:1}
      p_i &= a_i \oplus b_i \oplus c_i\\
      b_i &= a_i \oplus c_i \oplus p_i
    \end{align}
    Problème : tout accès en écriture nécessite un accès à la parité
    $\Longrightarrow$ goulet d'étranglement !

    RAID-5 : répartition de la parité cycliquement sur les disques pour
    paralléliser les accès :

    \begin{center}
      \begin{tabular}{|c||c|c|c|c|}
        \hline
        & $D_1$ & $D_2$ & $D_3$ & $D_4$ \\\hline\hline
        $B_1$ & $a_1$ & $b_1$ & $c_1$ & $p_1$\\\hline
        $B_2$ & $p_2$ & $a_2$ & $b_2$ & $c_2$\\\hline
        $B_3$ & $c_3$ & $p_3$ & $a_3$ & $b_3$\\\hline
        $B_4$ & $b_4$ & $c_4$ & $p_4$ & $a_4$\\\hline
        $B_5$ & $a_5$ & $b_5$ & $c_5$ & $p_5$\\\hline
      \end{tabular}
    \end{center}
  \item $\exists$ autres combinaisons de RAID
  \end{description}
\end{trans}


\subsubsection{ZFS}


\begin{trans}{ZFS de OpenSolaris Sun}
  \begin{itemize}
  \item Essaye de dépasser limitations systèmes de fichiers classiques
    \begin{itemize}
    \item Intégrité des données
    \item Extensibilité
    \item Sémantique transactionnelle
    \item Administration simple
    \item Disparition de la limite de disques ou partitions
    \item Gère ordre des octets
    \end{itemize}
  \item \vavers Zetabyte File System
  \end{itemize}
  \LienPDF{http://opensolaris.org/os/community/zfs/docs}
\end{trans}


\begin{trans}{Concepts de ZFS}
  \begin{itemize}
  \item Copie sur écriture pour avoir toujours vieilles données valides et
    journalisation
  \item Permet de rajouter facilement modèle transactionnel
  \item Codes de vérification pour détecter corruption
  \item Réplication avec RAID-Z, évite corruption RAID-5 (si panne de
    courant entre écriture donnée et parité) car copie sur
    écriture. Adaptation taille des bandes en fonction débit de chaque
    disque
  \item Inspection des fichiers et réparation en tâche de fond
  \item Optimise parallélisme et ordonnancement des ressources, E/S dans
    le désordre en respectant graphe de dépendance, tableau noir
    (\emph{scoreboard})
  \item Instantanés (\emph{snapshots}) (lecture seule) et clones
    (lecture-écriture) en temps constant. Pratique pour sauvegardes
  \item Possibilité de faire des différences d'instantanés (sauvegardes
    incrémentales, réplication à distance)
  \item Compression des données à la volée permet de réduire E/S d'un
    facteur 2--3 et peut être gagnant outre gain en capacité
  \item Permet d'exporter des pseudo-blocs de disque : swap, bases de
    données, systèmes de fichiers... pour bénéficier avantages ZFS
  \item Identifiants sur 128 bits
    \begin{itemize}
    \item $2^{64}$ caractères par fichier
    \item $2^{48}$ fichiers par répertoires accédés par table de hachage
    \item $2^{64}$ instantanés
    \item $2^{64}$ disques
    \end{itemize}
  \end{itemize}
\end{trans}


\begin{trans}{Déploiement de ZFS}
  \begin{itemize}
  \item (Open)Solaris
  \item MacOS X
  \item BSD
  \item Linux : problème de licence GPLMpour rajouter quelque chose dans
    le noyau dont ZFS en CDDL. Possible de tourner en mode utilisateur
    avec FUSE mais $\searrow\searrow$ performances $\frownie$
  \end{itemize}
\end{trans}


\subsection{Pilote de périphérique}

\begin{trans}{Contrôleur ou pilote de périphérique}
  \begin{itemizer}
  \item Besoin de contrôler les périphériques de bas niveau par le système
    d'exploitation, voire par l'utilisateur
  \item Pendant logiciel au périphérique matériel : \emph{device driver}
    ou contrôleur/pilote de périphérique
  \item Essaye de réutiliser un maximum de code
  \item Exemple de Solaris (SVR4) : \emph{Device Driver Interface Driver-
      Kernel Interface} (DDI/DKI)
    \begin{itemizet}
    \item Définit les méthodes que doit implémenter un contrôleur de
      périphérique (\texttt{man -s 9e intro})
    \item Méthodes du noyau utilisables par le contrôleur de
      périphérique : gestion des DMA, des interruptions, de la mémoire,
      des messages d'erreur,... (\texttt{man -s 9f intro})
    \end{itemizet}
  \item Augmente la portabilité du système d'exploitation
  \end{itemizer}
  \psfiglarge{systemes_exploitation/ES_bas_niveau.idraw}
\end{trans}


\begin{trans}{Types de pilotes de périphériques}
  \begin{itemizer}
  \item Certains périphériques ne peuvent envoyer ou recevoir des données
    que par une taille fixe de données sinon erreur
    \begin{itemizet}
    \item Clavier, imprimante : \emph{caractère} par \emph{caractère}
      (cela se passe en général bien pour en lire plusieurs)
    \item Réseau : des paquets Ethernet entier par exemple en mode
      \emph{brut}
    \item Disque dur, disquette : par bloc ou secteur (style 512 octets)
      en mode brut
    \end{itemizet}
    Ce sont des périphériques de type \emph{caractère}. Nom malheureux car
    regroupe aussi bien des pilotes gérant effectivement des caractère ou
    des paquets de données (mode brut ou \emph{raw})
  \item Besoin parfois d'avoir un périphérique utilisable avec n'importe
    quel nombre d'octets
    \begin{itemizet}
    \item Faire des \texttt{read}, \texttt{write}, \texttt{printf} sans
      soucis
    \item Le système offre la possibilité de rajouter une couche de
      tampon pour cacher cette taille fixe
    \item Exemple : si écriture de 10 octets sur disque, le système lit 2
      blocs du disque concernés par ces octets, les modifie et les réécrit
    \end{itemizet}
    Ce sont des périphériques de type bloc (nom malheureux encore...
  \item Certains pilotes sont mieux gérés avec une architecture en couche
    :
    \begin{itemizet}
    \item Protocoles réseau (couches)
    \item Terminaux (caractères de contrôles, gestion des modems ou
      liaison série,...)
    \item FIFO
    \end{itemizet}
    Pilote de type STREAM
  \end{itemizer}
\end{trans}


\begin{trans}{Quelques méthodes d'un pilote DDI/DKI}
  Minimum à écrire pour avoir un pilote : \texttt{open}, \texttt{read} ou
  \texttt{write} et \texttt{close}
  \begin{description}
  \item[\texttt{chpoll} :] poll entry point for a non-STREAMS character
    driver
  \item[\texttt{close} :] relinquish access to a device
  \item[\texttt{ioctl} :] control a character device (sert à tout et
    n'importe quoi)
  \item[\texttt{mmap} :] check virtual mapping for memory mapped device
  \item[\texttt{open} :] gain access to a device
  \item[\texttt{print} :] display a driver message on system console
  \item[\texttt{put} :] receive messages from the preceding queue
    (STREAMS)
  \item[\texttt{read} :] read data from a device
  \item[\texttt{srv} :] service queued messages
  \item[\texttt{strategy} :] perform block I/O. Appelé par le noyau pour
    faire des accès par bloc et remplir vider ses tampons pleins pour le
    pilote en mode bloc. Aussi utilisé par \texttt{read} et \texttt{write}
    si périphérique orienté bloc mais utilisé en mode brut (\emph{raw})
    donc caractère
  \item[\texttt{write} :] write data to a device
  \end{description}
  Il y a aussi des choses purement Solaris (gestion tolérance aux pannes,
  hibernation de la machine,...)
\end{trans}


\section{Systèmes de fichiers distants}


\begin{trans}{Pouvoir délocaliser les fichiers}
  \begin{itemizer}
  \item Dès début années 1970 développement des réseaux et protocoles de
    transfert de fichiers : UUCP, FTP,...
  \item Pas très élégant car pas de vision globale du système
  \item[\vavers{}] Émergence de systèmes de fichiers permettant des accès
    transparents aux fichiers distants dans les années 1980
    \begin{itemizet}
    \item \emph{Network File System} (NFS) de Sun Microsystems
    \item \emph{Remote File Sharing} (RFS) d'AT\&T
    \item \emph{Andrew File System} (AFS) de Carnegie-Mellon University
      qui a évolué en \emph{Distributed File System} d'OSF/DCE
    \end{itemizet}
  \end{itemizer}
\end{trans}


\begin{trans}{Propriétés importantes}
   Un système de fichiers distribué peut avoir :
   \begin{itemizer}
   \item Transparence de l'accès distant
   \item Transparence de la localisation
   \item Nom indépendant de la localisation
   \item Mobilité possible de l'utilisateur
   \item Tolérance aux pannes
   \item Extensibilité
   \item Mobilité des fichiers
   \end{itemizer}
\end{trans}


\begin{trans}{Considérations de conception}
  \begin{itemizer}
  \item Espace de nommage : uniforme ou pas
    \begin{itemizet}
    \item Espace de nommage uniforme : la localisation n'apparaît pas
    \item Un client peut greffer (« monter ») une arborescence distante
      dans sa propre hiérarchie avec un nom, voire un usage (FTP,...),
      dépendant de la machine distante
  \end{itemizet}
  \item Fonctionnement avec ou sans état du serveur\\
    Certaines requêtes possèdent un état qu'il faut stocker quelque part :
    \texttt{open}, \texttt{lseek},...
    \begin{itemizet}
    \item Serveur sans état persistant : chaque client doit envoyer des
      requêtes auto-suffisantes (position dans le fichier où on doit
      écrire,...). Serveur plus simple
    \item Serveur avec état persistant : conserve des informations sur les
      clients, moins de trafic réseau mais plus complexe (récupération de
      l'état en cas de plantage du serveur,...)
    \end{itemizet}

    \newslide

  \item Sémantique du partage
    \begin{itemizet}
    \item Sémantique Unix : toute modification par un client doit être
      visible immédiatement par un autre client. Contrainte forte
      \vavers{} $\searrow$ performances
    \item Sémantique de session : modifications propagées aux autres
      clients qu'au niveau du \texttt{close} ou à intervalle régulier,...
    \end{itemizet}
  \item Méthodes d'accès à distance : pas toujours limitées à un simple
    modèle client-serveur dans le cas d'un serveur à état à cause du
    mécanisme de récupération de panne du serveur
  \end{itemizer}
\end{trans}


\subsection{NFS}


\begin{trans}{Network File System (NFS)}
  \begin{itemizer}
  \item Introduit en 1985 avec la version 2 par Sun Microsystem
    \item Accès transparent à des systèmes de fichiers distants
      \begin{multicols}{2}
        \psfiglarge{systemes_exploitation/Administration_Unix/hierarchie_UNIX.idraw}
        \psfiglarge{systemes_exploitation/Administration_Unix/hierarchie_UNIX_dist.idraw}
      \end{multicols}
    \item Standard \emph{de facto}
    \item Modèle client-serveur
      \begin{itemizet}
      \item Serveur de fichiers exporte un ensemble de fichiers
      \item Clients de NFS accèdent à ces fichiers
      \item Possible avoir machines à la fois clients et serveurs
      \item Communications par des \emph{Remote Procedure Call}
      \end{itemizet}
  \end{itemizer}
\end{trans}


\begin{trans}{Buts de conceptions}
  \begin{itemizer}
    \item Non restreint à Unix
    \item Protocole indépendant du matériel
    \item Mécanisme simple de récupération après plantage du client ou
      serveur
    \item Accès transparents pour les applications : pas de noms,
      bibliothèque ou compilation spécifiques
    \item Sémantique Unix maintenue dans le cas de clients Unix
    \item Performances NFS comparables à celles des disques locaux
    \item Réalisation indépendante de la couche transport
  \end{itemizer}
\end{trans}


\begin{trans}{Composants de NFS}
  \begin{itemizer}
  \item Protocole RPC : interaction entre client et serveur, invocation de
    fonctions distantes avec passage d'arguments locaux et récupération
    des résultats
    \item \emph{External Data Representation} (XDR) : encodage des
      informations indépendant de l'harchitecture matérielle
    \item Programme du serveur NFS : gère requêtes des clients
    \item Programme du client NFS : transforme appels systèmes aux
      fichiers distants en appels RPC aux serveurs NFS
    \item Protocole de montage : gère montage et démontage des systèmes de
      fichiers NFS
    \item Plusieurs processus « démons » : \texttt{nfsd} gère les requêtes
      NFS et \texttt{mountd} gère montage sur serveur, \texttt{biod} gère
      sur le client les entrées-sorties asynchrones à des blocs de
      fichiers
    \item Rajout mécanisme de verrou sur fichiers via NFS avec
      \emph{Network File System} et \emph{Network Status Monitor}
      (\texttt{lockd} et \texttt{statd})
  \end{itemizer}
\end{trans}


\begin{trans}{NFS : sans état}
  \begin{itemizer}
  \item Pas d'état concernant le client dans le serveur
  \item Chaque requête auto-suffisante et indépendante des autres
  \item Pas de mécansime d'\texttt{open} ou \texttt{close}
  \item Les \texttt{READ} et \texttt{WRITE} doivent contenir leur propre
    \emph{offset}
  \item Plantage du client : besoin de remonter le système de fichiers
  \item Plantage du serveur : client répète ses requêtes jusqu'à une
    réponse. Pas de différence entre serveur lent ou serveur qui
    redémarre...
  \item Sans état
    \begin{itemizet}
    \item Protocole séparé pour le verrouillage (NLM)
    \item Toute modification des fichiers doivent être écrits sur disques
      du serveur avant de répondre au client car en cas de plantage client
      ne serait jamais au courant de la perte d'information... \vavers{}
      Lent, accélérateurs matériels, NFS v.3
    \end{itemizet}
  \end{itemizer}
\end{trans}


\section{Conclusion}


\begin{trans}{Conclusion}
  \begin{itemizer}
  \item Informatique et donc systèmes d'exploitation : partout !
  \item Ingénieur \vavers{} comprendre comment cela marche
  \item $\exists$ quelque chose derrière les interfaces graphiques
  \item Savoir bien utiliser le système
  \item Donne plein d'exemples de bonnes idées pour la gestion de
  ressources \smiley
  \item Continuer l'apprentissage du C 
  \end{itemizer}
\end{trans}


%\begin{frame}[allowframebreaks]{Table des matières}
  %% Fait quelque chose de compact :
%%BUG

\section*{Table des matières}

  \begin{multicols}{2}
    \tableofcontents[frametitles]
  \end{multicols}
%\end{frame}


\end{document}

%%% Local Variable
%%% TeX-master: "trans"
%%% End: 
